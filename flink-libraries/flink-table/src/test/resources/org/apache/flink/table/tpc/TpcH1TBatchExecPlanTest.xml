<?xml version="1.0" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<Root>
  <TestCase name="test[caseName=01, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- using 1395599672 as a seed to the RNG

select
  l_returnflag,
  l_linestatus,
  sum(l_quantity) as sum_qty,
  sum(l_extendedprice) as sum_base_price,
  sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
  sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
  avg(l_quantity) as avg_qty,
  avg(l_extendedprice) as avg_price,
  avg(l_discount) as avg_disc,
  count(*) as count_order
from
  lineitem
where
  l_shipdate <= date '1998-12-01' - interval '120' day (3)
group by
  l_returnflag,
  l_linestatus

order by
  l_returnflag,
  l_linestatus
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1}], sum_qty=[SUM($2)], sum_base_price=[SUM($3)], sum_disc_price=[SUM($4)], sum_charge=[SUM($5)], avg_qty=[AVG($2)], avg_price=[AVG($3)], avg_disc=[AVG($6)], count_order=[COUNT()])
   +- LogicalProject(l_returnflag=[$8], l_linestatus=[$9], l_quantity=[$4], l_extendedprice=[$5], $f4=[*($5, -(1, $6))], $f5=[*(*($5, -(1, $6)), +(1, $7))], l_discount=[$6])
      +- LogicalFilter(condition=[<=($10, -(1998-12-01, 10368000000))])
         +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, CAST(/(sum_qty, $f6)) AS avg_qty, CAST(/(sum_base_price, $f6)) AS avg_price, CAST(/($f7, $f6)) AS avg_disc, $f6 AS count_order])
+- SortLimit(orderBy=[l_returnflag ASC, l_linestatus ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[l_returnflag ASC, l_linestatus ASC], offset=[0], limit=[200], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[l_returnflag, l_linestatus], select=[l_returnflag, l_linestatus, Final_$SUM0(sum0$0) AS sum_qty, Final_$SUM0(sum0$1) AS sum_base_price, Final_$SUM0(sum0$2) AS sum_disc_price, Final_$SUM0(sum0$3) AS sum_charge, Final_COUNT(count$4) AS $f6, Final_$SUM0(sum0$5) AS $f7])
            +- Exchange(distribution=[hash[l_returnflag, l_linestatus]])
               +- LocalHashAggregate(groupBy=[l_returnflag, l_linestatus], select=[l_returnflag, l_linestatus, Partial_$SUM0(l_quantity) AS sum0$0, Partial_$SUM0(l_extendedprice) AS sum0$1, Partial_$SUM0($f4) AS sum0$2, Partial_$SUM0($f5) AS sum0$3, Partial_COUNT(*) AS count$4, Partial_$SUM0(l_discount) AS sum0$5])
                  +- Calc(select=[l_returnflag, l_linestatus, l_quantity, l_extendedprice, *(l_extendedprice, -(1, l_discount)) AS $f4, *(*(l_extendedprice, -(1, l_discount)), +(1, l_tax)) AS $f5, l_discount], where=[<=(l_shipdate, 1998-08-03)])
                     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate];filterPredicates=[]]]], fields=[l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=01, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- using 1395599672 as a seed to the RNG

select
  l_returnflag,
  l_linestatus,
  sum(l_quantity) as sum_qty,
  sum(l_extendedprice) as sum_base_price,
  sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
  sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
  avg(l_quantity) as avg_qty,
  avg(l_extendedprice) as avg_price,
  avg(l_discount) as avg_disc,
  count(*) as count_order
from
  lineitem
where
  l_shipdate <= date '1998-12-01' - interval '120' day (3)
group by
  l_returnflag,
  l_linestatus

order by
  l_returnflag,
  l_linestatus
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1}], sum_qty=[SUM($2)], sum_base_price=[SUM($3)], sum_disc_price=[SUM($4)], sum_charge=[SUM($5)], avg_qty=[AVG($2)], avg_price=[AVG($3)], avg_disc=[AVG($6)], count_order=[COUNT()])
   +- LogicalProject(l_returnflag=[$8], l_linestatus=[$9], l_quantity=[$4], l_extendedprice=[$5], $f4=[*($5, -(1, $6))], $f5=[*(*($5, -(1, $6)), +(1, $7))], l_discount=[$6])
      +- LogicalFilter(condition=[<=($10, -(1998-12-01, 10368000000))])
         +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, CAST(/(sum_qty, $f6)) AS avg_qty, CAST(/(sum_base_price, $f6)) AS avg_price, CAST(/($f7, $f6)) AS avg_disc, $f6 AS count_order])
+- SortLimit(orderBy=[l_returnflag ASC, l_linestatus ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[l_returnflag ASC, l_linestatus ASC], offset=[0], limit=[200], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[l_returnflag, l_linestatus], select=[l_returnflag, l_linestatus, Final_$SUM0(sum0$0) AS sum_qty, Final_$SUM0(sum0$1) AS sum_base_price, Final_$SUM0(sum0$2) AS sum_disc_price, Final_$SUM0(sum0$3) AS sum_charge, Final_COUNT(count$4) AS $f6, Final_$SUM0(sum0$5) AS $f7])
            +- Exchange(distribution=[hash[l_returnflag, l_linestatus]])
               +- LocalHashAggregate(groupBy=[l_returnflag, l_linestatus], select=[l_returnflag, l_linestatus, Partial_$SUM0(l_quantity) AS sum0$0, Partial_$SUM0(l_extendedprice) AS sum0$1, Partial_$SUM0($f4) AS sum0$2, Partial_$SUM0($f5) AS sum0$3, Partial_COUNT(*) AS count$4, Partial_$SUM0(l_discount) AS sum0$5])
                  +- Calc(select=[l_returnflag, l_linestatus, l_quantity, l_extendedprice, *(l_extendedprice, -(1, l_discount)) AS $f4, *(*(l_extendedprice, -(1, l_discount)), +(1, l_tax)) AS $f5, l_discount], where=[<=(l_shipdate, 1998-08-03)])
                     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate];filterPredicates=[]]]], fields=[l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=01, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- using 1395599672 as a seed to the RNG

select
  l_returnflag,
  l_linestatus,
  sum(l_quantity) as sum_qty,
  sum(l_extendedprice) as sum_base_price,
  sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
  sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
  avg(l_quantity) as avg_qty,
  avg(l_extendedprice) as avg_price,
  avg(l_discount) as avg_disc,
  count(*) as count_order
from
  lineitem
where
  l_shipdate <= date '1998-12-01' - interval '120' day (3)
group by
  l_returnflag,
  l_linestatus

order by
  l_returnflag,
  l_linestatus
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1}], sum_qty=[SUM($2)], sum_base_price=[SUM($3)], sum_disc_price=[SUM($4)], sum_charge=[SUM($5)], avg_qty=[AVG($2)], avg_price=[AVG($3)], avg_disc=[AVG($6)], count_order=[COUNT()])
   +- LogicalProject(l_returnflag=[$8], l_linestatus=[$9], l_quantity=[$4], l_extendedprice=[$5], $f4=[*($5, -(1, $6))], $f5=[*(*($5, -(1, $6)), +(1, $7))], l_discount=[$6])
      +- LogicalFilter(condition=[<=($10, -(1998-12-01, 10368000000))])
         +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, CAST(/(sum_qty, $f6)) AS avg_qty, CAST(/(sum_base_price, $f6)) AS avg_price, CAST(/($f7, $f6)) AS avg_disc, $f6 AS count_order])
+- SortLimit(orderBy=[l_returnflag ASC, l_linestatus ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[l_returnflag ASC, l_linestatus ASC], offset=[0], limit=[200], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[l_returnflag, l_linestatus], select=[l_returnflag, l_linestatus, Final_$SUM0(sum0$0) AS sum_qty, Final_$SUM0(sum0$1) AS sum_base_price, Final_$SUM0(sum0$2) AS sum_disc_price, Final_$SUM0(sum0$3) AS sum_charge, Final_COUNT(count$4) AS $f6, Final_$SUM0(sum0$5) AS $f7])
            +- Exchange(distribution=[hash[l_returnflag, l_linestatus]])
               +- LocalHashAggregate(groupBy=[l_returnflag, l_linestatus], select=[l_returnflag, l_linestatus, Partial_$SUM0(l_quantity) AS sum0$0, Partial_$SUM0(l_extendedprice) AS sum0$1, Partial_$SUM0($f4) AS sum0$2, Partial_$SUM0($f5) AS sum0$3, Partial_COUNT(*) AS count$4, Partial_$SUM0(l_discount) AS sum0$5])
                  +- Calc(select=[l_returnflag, l_linestatus, l_quantity, l_extendedprice, *(l_extendedprice, -(1, l_discount)) AS $f4, *(*(l_extendedprice, -(1, l_discount)), +(1, l_tax)) AS $f5, l_discount], where=[<=(l_shipdate, 1998-08-03)])
                     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate];filterPredicates=[]]]], fields=[l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=02, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch2 using 1395599672 as a seed to the RNG
select
  s.s_acctbal,
  s.s_name,
  n.n_name,
  p.p_partkey,
  p.p_mfgr,
  s.s_address,
  s.s_phone,
  s.s_comment
from
  part p,
  supplier s,
  partsupp ps,
  nation n,
  region r
where
  p.p_partkey = ps.ps_partkey
  and s.s_suppkey = ps.ps_suppkey
  and p.p_size = 41
  and p.p_type like '%NICKEL'
  and s.s_nationkey = n.n_nationkey
  and n.n_regionkey = r.r_regionkey
  and r.r_name = 'EUROPE'
  and ps.ps_supplycost = (

    select
      min(ps.ps_supplycost)

    from
      partsupp ps,
      supplier s,
      nation n,
      region r
    where
      p.p_partkey = ps.ps_partkey
      and s.s_suppkey = ps.ps_suppkey
      and s.s_nationkey = n.n_nationkey
      and n.n_regionkey = r.r_regionkey
      and r.r_name = 'EUROPE'
  )

order by
  s.s_acctbal desc,
  n.n_name,
  s.s_name,
  p.p_partkey
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$2], sort2=[$1], sort3=[$3], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first], dir3=[ASC-nulls-first], fetch=[100])
+- LogicalProject(s_acctbal=[$14], s_name=[$10], n_name=[$22], p_partkey=[$0], p_mfgr=[$2], s_address=[$11], s_phone=[$13], s_comment=[$15])
   +- LogicalFilter(condition=[AND(=($0, $16), =($9, $17), =($5, 41), LIKE($4, '%NICKEL'), =($12, $21), =($23, $25), =($26, 'EUROPE'), =($19, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[MIN($0)])
  LogicalProject(ps_supplycost=[$3])
    LogicalFilter(condition=[AND(=($cor0.p_partkey, $0), =($5, $1), =($8, $12), =($14, $16), =($17, 'EUROPE'))])
      LogicalJoin(condition=[true], joinType=[inner])
        LogicalJoin(condition=[true], joinType=[inner])
          LogicalJoin(condition=[true], joinType=[inner])
            LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
          LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
        LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalJoin(condition=[true], joinType=[inner])
         :  :- LogicalJoin(condition=[true], joinType=[inner])
         :  :  :- LogicalJoin(condition=[true], joinType=[inner])
         :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
         :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         :  :  +- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
         :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment])
+- SortLimit(orderBy=[s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], offset=[0], limit=[100], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], offset=[0], limit=[100], global=[false])
         +- Rank(rankFunction=[RANK], partitionBy=[p_partkey], orderBy=[ps_supplycost ASC], rankRange=[rankStart=1, rankEnd=1], global=[true], select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment, rk])
            +- Sort(orderBy=[p_partkey ASC, ps_supplycost ASC])
               +- Exchange(distribution=[hash[p_partkey]])
                  +- Rank(rankFunction=[RANK], partitionBy=[p_partkey], orderBy=[ps_supplycost ASC], rankRange=[rankStart=1, rankEnd=1], global=[false], select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment])
                     +- Sort(orderBy=[p_partkey ASC, ps_supplycost ASC])
                        +- Calc(select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment])
                           +- HashJoin(where=[=(s_suppkey, ps_suppkey)], join=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], joinType=[InnerJoin], build=[right])
                              :- Exchange(distribution=[hash[s_suppkey]])
                              :  +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment], joinType=[InnerJoin], build=[right])
                              :     :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment])
                              :     +- Exchange(distribution=[broadcast])
                              :        +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment], joinType=[InnerJoin], build=[right])
                              :           :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]], fields=[n_nationkey, n_name, n_regionkey, n_comment])
                              :           +- Exchange(distribution=[broadcast])
                              :              +- Calc(select=[r_regionkey, r_name, r_comment], where=[=(r_name, 'EUROPE')])
                              :                 +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]], fields=[r_regionkey, r_name, r_comment])
                              +- Exchange(distribution=[hash[ps_suppkey]])
                                 +- HashJoin(where=[=(p_partkey, ps_partkey)], join=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], joinType=[InnerJoin], build=[left])
                                    :- Exchange(distribution=[hash[p_partkey]])
                                    :  +- Calc(select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment], where=[AND(=(p_size, 41), LIKE(p_type, '%NICKEL'), RUNTIME_FILTER_BUILDER_0(p_partkey))])
                                    :     +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]], fields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment])
                                    +- Exchange(distribution=[hash[ps_partkey]])
                                       +- Calc(select=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], where=[RUNTIME_FILTER_0(ps_partkey)])
                                          +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=02, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch2 using 1395599672 as a seed to the RNG
select
  s.s_acctbal,
  s.s_name,
  n.n_name,
  p.p_partkey,
  p.p_mfgr,
  s.s_address,
  s.s_phone,
  s.s_comment
from
  part p,
  supplier s,
  partsupp ps,
  nation n,
  region r
where
  p.p_partkey = ps.ps_partkey
  and s.s_suppkey = ps.ps_suppkey
  and p.p_size = 41
  and p.p_type like '%NICKEL'
  and s.s_nationkey = n.n_nationkey
  and n.n_regionkey = r.r_regionkey
  and r.r_name = 'EUROPE'
  and ps.ps_supplycost = (

    select
      min(ps.ps_supplycost)

    from
      partsupp ps,
      supplier s,
      nation n,
      region r
    where
      p.p_partkey = ps.ps_partkey
      and s.s_suppkey = ps.ps_suppkey
      and s.s_nationkey = n.n_nationkey
      and n.n_regionkey = r.r_regionkey
      and r.r_name = 'EUROPE'
  )

order by
  s.s_acctbal desc,
  n.n_name,
  s.s_name,
  p.p_partkey
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$2], sort2=[$1], sort3=[$3], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first], dir3=[ASC-nulls-first], fetch=[100])
+- LogicalProject(s_acctbal=[$14], s_name=[$10], n_name=[$22], p_partkey=[$0], p_mfgr=[$2], s_address=[$11], s_phone=[$13], s_comment=[$15])
   +- LogicalFilter(condition=[AND(=($0, $16), =($9, $17), =($5, 41), LIKE($4, '%NICKEL'), =($12, $21), =($23, $25), =($26, 'EUROPE'), =($19, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[MIN($0)])
  LogicalProject(ps_supplycost=[$3])
    LogicalFilter(condition=[AND(=($cor0.p_partkey, $0), =($5, $1), =($8, $12), =($14, $16), =($17, 'EUROPE'))])
      LogicalJoin(condition=[true], joinType=[inner])
        LogicalJoin(condition=[true], joinType=[inner])
          LogicalJoin(condition=[true], joinType=[inner])
            LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
          LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
        LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalJoin(condition=[true], joinType=[inner])
         :  :- LogicalJoin(condition=[true], joinType=[inner])
         :  :  :- LogicalJoin(condition=[true], joinType=[inner])
         :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
         :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         :  :  +- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
         :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment])
+- SortLimit(orderBy=[s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], offset=[0], limit=[100], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], offset=[0], limit=[100], global=[false])
         +- Rank(rankFunction=[RANK], partitionBy=[p_partkey], orderBy=[ps_supplycost ASC], rankRange=[rankStart=1, rankEnd=1], global=[true], select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment, rk])
            +- Sort(orderBy=[p_partkey ASC, ps_supplycost ASC])
               +- Exchange(distribution=[hash[p_partkey]])
                  +- Rank(rankFunction=[RANK], partitionBy=[p_partkey], orderBy=[ps_supplycost ASC], rankRange=[rankStart=1, rankEnd=1], global=[false], select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment])
                     +- Sort(orderBy=[p_partkey ASC, ps_supplycost ASC])
                        +- Calc(select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment])
                           +- HashJoin(where=[=(s_suppkey, ps_suppkey)], join=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], joinType=[InnerJoin], build=[left])
                              :- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                              :  :- Exchange(distribution=[hash[s_suppkey]])
                              :  :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment])
                              :  +- Exchange(distribution=[broadcast])
                              :     +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment], joinType=[InnerJoin], build=[right])
                              :        :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]], fields=[n_nationkey, n_name, n_regionkey, n_comment])
                              :        +- Exchange(distribution=[broadcast])
                              :           +- Calc(select=[r_regionkey, r_name, r_comment], where=[=(r_name, 'EUROPE')])
                              :              +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]], fields=[r_regionkey, r_name, r_comment])
                              +- Exchange(distribution=[hash[ps_suppkey]])
                                 +- HashJoin(where=[=(p_partkey, ps_partkey)], join=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], joinType=[InnerJoin], build=[left])
                                    :- Exchange(distribution=[hash[p_partkey]])
                                    :  +- Calc(select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment], where=[AND(=(p_size, 41), LIKE(p_type, '%NICKEL'))])
                                    :     +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]], fields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment])
                                    +- Exchange(distribution=[hash[ps_partkey]])
                                       +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=02, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch2 using 1395599672 as a seed to the RNG
select
  s.s_acctbal,
  s.s_name,
  n.n_name,
  p.p_partkey,
  p.p_mfgr,
  s.s_address,
  s.s_phone,
  s.s_comment
from
  part p,
  supplier s,
  partsupp ps,
  nation n,
  region r
where
  p.p_partkey = ps.ps_partkey
  and s.s_suppkey = ps.ps_suppkey
  and p.p_size = 41
  and p.p_type like '%NICKEL'
  and s.s_nationkey = n.n_nationkey
  and n.n_regionkey = r.r_regionkey
  and r.r_name = 'EUROPE'
  and ps.ps_supplycost = (

    select
      min(ps.ps_supplycost)

    from
      partsupp ps,
      supplier s,
      nation n,
      region r
    where
      p.p_partkey = ps.ps_partkey
      and s.s_suppkey = ps.ps_suppkey
      and s.s_nationkey = n.n_nationkey
      and n.n_regionkey = r.r_regionkey
      and r.r_name = 'EUROPE'
  )

order by
  s.s_acctbal desc,
  n.n_name,
  s.s_name,
  p.p_partkey
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$2], sort2=[$1], sort3=[$3], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first], dir3=[ASC-nulls-first], fetch=[100])
+- LogicalProject(s_acctbal=[$14], s_name=[$10], n_name=[$22], p_partkey=[$0], p_mfgr=[$2], s_address=[$11], s_phone=[$13], s_comment=[$15])
   +- LogicalFilter(condition=[AND(=($0, $16), =($9, $17), =($5, 41), LIKE($4, '%NICKEL'), =($12, $21), =($23, $25), =($26, 'EUROPE'), =($19, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[MIN($0)])
  LogicalProject(ps_supplycost=[$3])
    LogicalFilter(condition=[AND(=($cor0.p_partkey, $0), =($5, $1), =($8, $12), =($14, $16), =($17, 'EUROPE'))])
      LogicalJoin(condition=[true], joinType=[inner])
        LogicalJoin(condition=[true], joinType=[inner])
          LogicalJoin(condition=[true], joinType=[inner])
            LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
          LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
        LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalJoin(condition=[true], joinType=[inner])
         :  :- LogicalJoin(condition=[true], joinType=[inner])
         :  :  :- LogicalJoin(condition=[true], joinType=[inner])
         :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
         :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         :  :  +- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
         :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment])
+- SortLimit(orderBy=[s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], offset=[0], limit=[100], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], offset=[0], limit=[100], global=[false])
         +- Rank(rankFunction=[RANK], partitionBy=[p_partkey], orderBy=[ps_supplycost ASC], rankRange=[rankStart=1, rankEnd=1], global=[true], select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment, rk])
            +- Sort(orderBy=[p_partkey ASC, ps_supplycost ASC])
               +- Exchange(distribution=[hash[p_partkey]])
                  +- Rank(rankFunction=[RANK], partitionBy=[p_partkey], orderBy=[ps_supplycost ASC], rankRange=[rankStart=1, rankEnd=1], global=[false], select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment])
                     +- Sort(orderBy=[p_partkey ASC, ps_supplycost ASC])
                        +- Calc(select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment])
                           +- HashJoin(where=[=(s_suppkey, ps_suppkey)], join=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], joinType=[InnerJoin], build=[left])
                              :- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                              :  :- Exchange(distribution=[hash[s_suppkey]])
                              :  :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment])
                              :  +- Exchange(distribution=[broadcast])
                              :     +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_name, n_regionkey, n_comment, r_regionkey, r_name, r_comment], joinType=[InnerJoin], build=[right])
                              :        :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]], fields=[n_nationkey, n_name, n_regionkey, n_comment])
                              :        +- Exchange(distribution=[broadcast])
                              :           +- Calc(select=[r_regionkey, r_name, r_comment], where=[=(r_name, 'EUROPE')])
                              :              +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]], fields=[r_regionkey, r_name, r_comment])
                              +- Exchange(distribution=[hash[ps_suppkey]])
                                 +- HashJoin(where=[=(p_partkey, ps_partkey)], join=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], joinType=[InnerJoin], build=[left])
                                    :- Exchange(distribution=[hash[p_partkey]])
                                    :  +- Calc(select=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment], where=[AND(=(p_size, 41), LIKE(p_type, '%NICKEL'))])
                                    :     +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]], fields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment])
                                    +- Exchange(distribution=[hash[ps_partkey]])
                                       +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=03, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch3 using 1395599672 as a seed to the RNG
select
  l.l_orderkey,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue,
  o.o_orderdate,
  o.o_shippriority

from
  customer c,
  orders o,
  lineitem l

where
  c.c_mktsegment = 'HOUSEHOLD'
  and c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and o.o_orderdate < date '1995-03-25'
  and l.l_shipdate > date '1995-03-25'

group by
  l.l_orderkey,
  o.o_orderdate,
  o.o_shippriority
order by
  revenue desc,
  o.o_orderdate
limit 10
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$2], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[10])
+- LogicalProject(l_orderkey=[$0], revenue=[$3], o_orderdate=[$1], o_shippriority=[$2])
   +- LogicalAggregate(group=[{0, 1, 2}], revenue=[SUM($3)])
      +- LogicalProject(l_orderkey=[$17], o_orderdate=[$12], o_shippriority=[$15], $f3=[*($22, -(1, $23))])
         +- LogicalFilter(condition=[AND(=($6, 'HOUSEHOLD'), =($0, $9), =($17, $8), <($12, 1995-03-25), >($27, 1995-03-25))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[l_orderkey, revenue, o_orderdate, o_shippriority])
+- SortLimit(orderBy=[revenue DESC, o_orderdate ASC], offset=[0], limit=[10], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[revenue DESC, o_orderdate ASC], offset=[0], limit=[10], global=[false])
         +- HashAggregate(isMerge=[false], groupBy=[l_orderkey], auxGrouping=[o_orderdate, o_shippriority], select=[l_orderkey, o_orderdate, o_shippriority, SUM($f3) AS revenue])
            +- Calc(select=[l_orderkey, o_orderdate, o_shippriority, *(l_extendedprice, -(1, l_discount)) AS $f3])
               +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, o_orderkey, o_orderdate, o_shippriority], joinType=[InnerJoin], build=[right])
                  :- Exchange(distribution=[hash[l_orderkey]])
                  :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount], where=[>(l_shipdate, 1995-03-25)])
                  :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_orderkey, l_extendedprice, l_discount, l_shipdate])
                  +- Exchange(distribution=[hash[o_orderkey]])
                     +- Calc(select=[o_orderkey, o_orderdate, o_shippriority])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, o_orderdate, o_shippriority, c_custkey], joinType=[InnerJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- Calc(select=[o_orderkey, o_custkey, o_orderdate, o_shippriority], where=[<(o_orderdate, 1995-03-25)])
                           :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate, o_shippriority];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate, o_shippriority])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- Calc(select=[c_custkey], where=[=(c_mktsegment, 'HOUSEHOLD')])
                                 +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_mktsegment];filterPredicates=[]]]], fields=[c_custkey, c_mktsegment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=03, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch3 using 1395599672 as a seed to the RNG
select
  l.l_orderkey,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue,
  o.o_orderdate,
  o.o_shippriority

from
  customer c,
  orders o,
  lineitem l

where
  c.c_mktsegment = 'HOUSEHOLD'
  and c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and o.o_orderdate < date '1995-03-25'
  and l.l_shipdate > date '1995-03-25'

group by
  l.l_orderkey,
  o.o_orderdate,
  o.o_shippriority
order by
  revenue desc,
  o.o_orderdate
limit 10
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$2], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[10])
+- LogicalProject(l_orderkey=[$0], revenue=[$3], o_orderdate=[$1], o_shippriority=[$2])
   +- LogicalAggregate(group=[{0, 1, 2}], revenue=[SUM($3)])
      +- LogicalProject(l_orderkey=[$17], o_orderdate=[$12], o_shippriority=[$15], $f3=[*($22, -(1, $23))])
         +- LogicalFilter(condition=[AND(=($6, 'HOUSEHOLD'), =($0, $9), =($17, $8), <($12, 1995-03-25), >($27, 1995-03-25))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[l_orderkey, revenue, o_orderdate, o_shippriority])
+- SortLimit(orderBy=[revenue DESC, o_orderdate ASC], offset=[0], limit=[10], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[revenue DESC, o_orderdate ASC], offset=[0], limit=[10], global=[false])
         +- HashAggregate(isMerge=[false], groupBy=[l_orderkey], auxGrouping=[o_orderdate, o_shippriority], select=[l_orderkey, o_orderdate, o_shippriority, SUM($f3) AS revenue])
            +- Calc(select=[l_orderkey, o_orderdate, o_shippriority, *(l_extendedprice, -(1, l_discount)) AS $f3])
               +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, o_orderkey, o_orderdate, o_shippriority], joinType=[InnerJoin], build=[right])
                  :- Exchange(distribution=[hash[l_orderkey]])
                  :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount], where=[>(l_shipdate, 1995-03-25)])
                  :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_orderkey, l_extendedprice, l_discount, l_shipdate])
                  +- Exchange(distribution=[hash[o_orderkey]])
                     +- Calc(select=[o_orderkey, o_orderdate, o_shippriority])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, o_orderdate, o_shippriority, c_custkey], joinType=[InnerJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- Calc(select=[o_orderkey, o_custkey, o_orderdate, o_shippriority], where=[<(o_orderdate, 1995-03-25)])
                           :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate, o_shippriority];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate, o_shippriority])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- Calc(select=[c_custkey], where=[=(c_mktsegment, 'HOUSEHOLD')])
                                 +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_mktsegment];filterPredicates=[]]]], fields=[c_custkey, c_mktsegment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=03, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch3 using 1395599672 as a seed to the RNG
select
  l.l_orderkey,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue,
  o.o_orderdate,
  o.o_shippriority

from
  customer c,
  orders o,
  lineitem l

where
  c.c_mktsegment = 'HOUSEHOLD'
  and c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and o.o_orderdate < date '1995-03-25'
  and l.l_shipdate > date '1995-03-25'

group by
  l.l_orderkey,
  o.o_orderdate,
  o.o_shippriority
order by
  revenue desc,
  o.o_orderdate
limit 10
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$2], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[10])
+- LogicalProject(l_orderkey=[$0], revenue=[$3], o_orderdate=[$1], o_shippriority=[$2])
   +- LogicalAggregate(group=[{0, 1, 2}], revenue=[SUM($3)])
      +- LogicalProject(l_orderkey=[$17], o_orderdate=[$12], o_shippriority=[$15], $f3=[*($22, -(1, $23))])
         +- LogicalFilter(condition=[AND(=($6, 'HOUSEHOLD'), =($0, $9), =($17, $8), <($12, 1995-03-25), >($27, 1995-03-25))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[l_orderkey, revenue, o_orderdate, o_shippriority])
+- SortLimit(orderBy=[revenue DESC, o_orderdate ASC], offset=[0], limit=[10], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[revenue DESC, o_orderdate ASC], offset=[0], limit=[10], global=[false])
         +- HashAggregate(isMerge=[false], groupBy=[l_orderkey], auxGrouping=[o_orderdate, o_shippriority], select=[l_orderkey, o_orderdate, o_shippriority, SUM($f3) AS revenue])
            +- Calc(select=[l_orderkey, o_orderdate, o_shippriority, *(l_extendedprice, -(1, l_discount)) AS $f3])
               +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, o_orderkey, o_orderdate, o_shippriority], joinType=[InnerJoin], build=[right])
                  :- Exchange(distribution=[hash[l_orderkey]])
                  :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount], where=[>(l_shipdate, 1995-03-25)])
                  :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_orderkey, l_extendedprice, l_discount, l_shipdate])
                  +- Exchange(distribution=[hash[o_orderkey]])
                     +- Calc(select=[o_orderkey, o_orderdate, o_shippriority])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, o_orderdate, o_shippriority, c_custkey], joinType=[InnerJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- Calc(select=[o_orderkey, o_custkey, o_orderdate, o_shippriority], where=[<(o_orderdate, 1995-03-25)])
                           :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate, o_shippriority];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate, o_shippriority])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- Calc(select=[c_custkey], where=[=(c_mktsegment, 'HOUSEHOLD')])
                                 +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_mktsegment];filterPredicates=[]]]], fields=[c_custkey, c_mktsegment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=04, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch4 using 1395599672 as a seed to the RNG
select
  o.o_orderpriority,
  count(*) as order_count
from
  orders o

where
  o.o_orderdate >= date '1996-10-01'
  and o.o_orderdate < date '1996-10-01' + interval '3' month
  and
  exists (
    select
      *
    from
      lineitem l
    where
      l.l_orderkey = o.o_orderkey
      and l.l_commitdate < l.l_receiptdate
  )
group by
  o.o_orderpriority
order by
  o.o_orderpriority
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], order_count=[COUNT()])
   +- LogicalProject(o_orderpriority=[$5])
      +- LogicalFilter(condition=[AND(>=($4, 1996-10-01), <($4, +(1996-10-01, 3)), EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.o_orderkey), <($11, $12))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}))], variablesSet=[[$cor0]])
         +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[o_orderpriority ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[o_orderpriority ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[o_orderpriority], select=[o_orderpriority, Final_COUNT(count$0) AS order_count])
         +- Exchange(distribution=[hash[o_orderpriority]])
            +- LocalHashAggregate(groupBy=[o_orderpriority], select=[o_orderpriority, Partial_COUNT(*) AS count$0])
               +- Calc(select=[o_orderpriority])
                  +- HashSemiJoin(where=[=(l_orderkey, o_orderkey)], join=[o_orderkey, o_orderpriority], joinType=[LeftSemiJoin], build=[left], tryDistinctBuildRow=[true])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- Calc(select=[o_orderkey, o_orderpriority], where=[AND(>=(o_orderdate, 1996-10-01), <(o_orderdate, 1997-01-01))])
                     :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderdate, o_orderpriority];filterPredicates=[]]]], fields=[o_orderkey, o_orderdate, o_orderpriority])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- LocalHashAggregate(groupBy=[l_orderkey], select=[l_orderkey])
                           +- Calc(select=[l_orderkey], where=[<(l_commitdate, l_receiptdate)])
                              +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_commitdate, l_receiptdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=04, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch4 using 1395599672 as a seed to the RNG
select
  o.o_orderpriority,
  count(*) as order_count
from
  orders o

where
  o.o_orderdate >= date '1996-10-01'
  and o.o_orderdate < date '1996-10-01' + interval '3' month
  and
  exists (
    select
      *
    from
      lineitem l
    where
      l.l_orderkey = o.o_orderkey
      and l.l_commitdate < l.l_receiptdate
  )
group by
  o.o_orderpriority
order by
  o.o_orderpriority
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], order_count=[COUNT()])
   +- LogicalProject(o_orderpriority=[$5])
      +- LogicalFilter(condition=[AND(>=($4, 1996-10-01), <($4, +(1996-10-01, 3)), EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.o_orderkey), <($11, $12))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}))], variablesSet=[[$cor0]])
         +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[o_orderpriority ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[o_orderpriority ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[o_orderpriority], select=[o_orderpriority, Final_COUNT(count$0) AS order_count])
         +- Exchange(distribution=[hash[o_orderpriority]])
            +- LocalHashAggregate(groupBy=[o_orderpriority], select=[o_orderpriority, Partial_COUNT(*) AS count$0])
               +- Calc(select=[o_orderpriority])
                  +- HashSemiJoin(where=[=(l_orderkey, o_orderkey)], join=[o_orderkey, o_orderpriority], joinType=[LeftSemiJoin], build=[left])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- Calc(select=[o_orderkey, o_orderpriority], where=[AND(>=(o_orderdate, 1996-10-01), <(o_orderdate, 1997-01-01))])
                     :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderdate, o_orderpriority];filterPredicates=[]]]], fields=[o_orderkey, o_orderdate, o_orderpriority])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[l_orderkey], where=[<(l_commitdate, l_receiptdate)])
                           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_commitdate, l_receiptdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=04, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch4 using 1395599672 as a seed to the RNG
select
  o.o_orderpriority,
  count(*) as order_count
from
  orders o

where
  o.o_orderdate >= date '1996-10-01'
  and o.o_orderdate < date '1996-10-01' + interval '3' month
  and
  exists (
    select
      *
    from
      lineitem l
    where
      l.l_orderkey = o.o_orderkey
      and l.l_commitdate < l.l_receiptdate
  )
group by
  o.o_orderpriority
order by
  o.o_orderpriority
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], order_count=[COUNT()])
   +- LogicalProject(o_orderpriority=[$5])
      +- LogicalFilter(condition=[AND(>=($4, 1996-10-01), <($4, +(1996-10-01, 3)), EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.o_orderkey), <($11, $12))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}))], variablesSet=[[$cor0]])
         +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[o_orderpriority ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[o_orderpriority ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[o_orderpriority], select=[o_orderpriority, Final_COUNT(count$0) AS order_count])
         +- Exchange(distribution=[hash[o_orderpriority]])
            +- LocalHashAggregate(groupBy=[o_orderpriority], select=[o_orderpriority, Partial_COUNT(*) AS count$0])
               +- Calc(select=[o_orderpriority])
                  +- HashSemiJoin(where=[=(l_orderkey, o_orderkey)], join=[o_orderkey, o_orderpriority], joinType=[LeftSemiJoin], build=[left])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- Calc(select=[o_orderkey, o_orderpriority], where=[AND(>=(o_orderdate, 1996-10-01), <(o_orderdate, 1997-01-01))])
                     :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderdate, o_orderpriority];filterPredicates=[]]]], fields=[o_orderkey, o_orderdate, o_orderpriority])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[l_orderkey], where=[<(l_commitdate, l_receiptdate)])
                           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_commitdate, l_receiptdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=05, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch5 using 1395599672 as a seed to the RNG
select
  n.n_name,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue

from
  customer c,
  orders o,
  lineitem l,
  supplier s,
  nation n,
  region r

where
  c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and l.l_suppkey = s.s_suppkey
  and c.c_nationkey = s.s_nationkey
  and s.s_nationkey = n.n_nationkey
  and n.n_regionkey = r.r_regionkey
  and r.r_name = 'EUROPE'
  and o.o_orderdate >= date '1997-01-01'
  and o.o_orderdate < date '1997-01-01' + interval '1' year
group by
  n.n_name

order by
  revenue desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], dir0=[DESC-nulls-last])
+- LogicalAggregate(group=[{0}], revenue=[SUM($1)])
   +- LogicalProject(n_name=[$41], $f1=[*($22, -(1, $23))])
      +- LogicalFilter(condition=[AND(=($0, $9), =($17, $8), =($19, $33), =($3, $36), =($36, $40), =($42, $44), =($45, 'EUROPE'), >=($12, 1997-01-01), <($12, +(1997-01-01, 12)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[revenue DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[n_name], select=[n_name, Final_SUM(sum$0) AS revenue])
         +- Exchange(distribution=[hash[n_name]])
            +- LocalHashAggregate(groupBy=[n_name], select=[n_name, Partial_SUM($f1) AS sum$0])
               +- Calc(select=[n_name, *(l_extendedprice, -(1, l_discount)) AS $f1])
                  +- HashJoin(where=[AND(=(l_suppkey, s_suppkey), =(n_nationkey, s_nationkey))], join=[l_suppkey, l_extendedprice, l_discount, n_nationkey, n_name, s_suppkey, s_nationkey], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_suppkey, n_nationkey]])
                     :  +- Calc(select=[l_suppkey, l_extendedprice, l_discount, n_nationkey, n_name])
                     :     +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_suppkey, l_extendedprice, l_discount, o_orderkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                     :        :- Exchange(distribution=[hash[l_orderkey]])
                     :        :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_extendedprice, l_discount])
                     :        +- Exchange(distribution=[hash[o_orderkey]])
                     :           +- Calc(select=[o_orderkey, n_nationkey, n_name])
                     :              +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                     :                 :- Exchange(distribution=[hash[o_custkey]])
                     :                 :  +- Calc(select=[o_orderkey, o_custkey], where=[AND(>=(o_orderdate, 1997-01-01), <(o_orderdate, 1998-01-01))])
                     :                 :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                     :                 +- Exchange(distribution=[hash[c_custkey]])
                     :                    +- Calc(select=[c_custkey, n_nationkey, n_name])
                     :                       +- NestedLoopJoin(where=[=(n_nationkey, c_nationkey)], join=[c_custkey, c_nationkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                     :                          :- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                     :                          +- Exchange(distribution=[broadcast])
                     :                             +- Calc(select=[n_nationkey, n_name])
                     :                                +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_name, n_regionkey, r_regionkey], joinType=[InnerJoin], build=[right])
                     :                                   :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey];filterPredicates=[]]]], fields=[n_nationkey, n_name, n_regionkey])
                     :                                   +- Exchange(distribution=[broadcast])
                     :                                      +- Calc(select=[r_regionkey], where=[=(r_name, 'EUROPE')])
                     :                                         +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name];filterPredicates=[]]]], fields=[r_regionkey, r_name])
                     +- Exchange(distribution=[hash[s_suppkey, s_nationkey]])
                        +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=05, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch5 using 1395599672 as a seed to the RNG
select
  n.n_name,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue

from
  customer c,
  orders o,
  lineitem l,
  supplier s,
  nation n,
  region r

where
  c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and l.l_suppkey = s.s_suppkey
  and c.c_nationkey = s.s_nationkey
  and s.s_nationkey = n.n_nationkey
  and n.n_regionkey = r.r_regionkey
  and r.r_name = 'EUROPE'
  and o.o_orderdate >= date '1997-01-01'
  and o.o_orderdate < date '1997-01-01' + interval '1' year
group by
  n.n_name

order by
  revenue desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], dir0=[DESC-nulls-last])
+- LogicalAggregate(group=[{0}], revenue=[SUM($1)])
   +- LogicalProject(n_name=[$41], $f1=[*($22, -(1, $23))])
      +- LogicalFilter(condition=[AND(=($0, $9), =($17, $8), =($19, $33), =($3, $36), =($36, $40), =($42, $44), =($45, 'EUROPE'), >=($12, 1997-01-01), <($12, +(1997-01-01, 12)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[revenue DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[n_name], select=[n_name, Final_SUM(sum$0) AS revenue])
         +- Exchange(distribution=[hash[n_name]])
            +- LocalHashAggregate(groupBy=[n_name], select=[n_name, Partial_SUM($f1) AS sum$0])
               +- Calc(select=[n_name, *(l_extendedprice, -(1, l_discount)) AS $f1])
                  +- HashJoin(where=[AND(=(l_suppkey, s_suppkey), =(l_orderkey, o_orderkey))], join=[l_orderkey, l_suppkey, l_extendedprice, l_discount, o_orderkey, n_name, s_suppkey], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_suppkey, l_orderkey]])
                     :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_extendedprice, l_discount])
                     +- Exchange(distribution=[hash[s_suppkey, o_orderkey]])
                        +- Calc(select=[o_orderkey, n_name, s_suppkey])
                           +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey, n_name, s_suppkey], joinType=[InnerJoin], build=[right])
                              :- Exchange(distribution=[hash[o_custkey]])
                              :  +- Calc(select=[o_orderkey, o_custkey], where=[AND(>=(o_orderdate, 1997-01-01), <(o_orderdate, 1998-01-01))])
                              :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                              +- Exchange(distribution=[hash[c_custkey]])
                                 +- Calc(select=[c_custkey, n_name, s_suppkey])
                                    +- HashJoin(where=[=(c_nationkey, s_nationkey)], join=[c_custkey, c_nationkey, n_name, s_suppkey, s_nationkey], joinType=[InnerJoin], build=[right])
                                       :- Calc(select=[c_custkey, c_nationkey, n_name])
                                       :  +- HashJoin(where=[=(n_nationkey, c_nationkey)], join=[c_custkey, c_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                                       :     :- Exchange(distribution=[hash[c_nationkey]])
                                       :     :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                                       :     +- Exchange(distribution=[broadcast])
                                       :        +- Calc(select=[n_nationkey, n_name])
                                       :           +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_name, n_regionkey, r_regionkey], joinType=[InnerJoin], build=[right])
                                       :              :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey];filterPredicates=[]]]], fields=[n_nationkey, n_name, n_regionkey])
                                       :              +- Exchange(distribution=[broadcast])
                                       :                 +- Calc(select=[r_regionkey], where=[=(r_name, 'EUROPE')])
                                       :                    +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name];filterPredicates=[]]]], fields=[r_regionkey, r_name])
                                       +- Exchange(distribution=[hash[s_nationkey]])
                                          +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=05, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch5 using 1395599672 as a seed to the RNG
select
  n.n_name,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue

from
  customer c,
  orders o,
  lineitem l,
  supplier s,
  nation n,
  region r

where
  c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and l.l_suppkey = s.s_suppkey
  and c.c_nationkey = s.s_nationkey
  and s.s_nationkey = n.n_nationkey
  and n.n_regionkey = r.r_regionkey
  and r.r_name = 'EUROPE'
  and o.o_orderdate >= date '1997-01-01'
  and o.o_orderdate < date '1997-01-01' + interval '1' year
group by
  n.n_name

order by
  revenue desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], dir0=[DESC-nulls-last])
+- LogicalAggregate(group=[{0}], revenue=[SUM($1)])
   +- LogicalProject(n_name=[$41], $f1=[*($22, -(1, $23))])
      +- LogicalFilter(condition=[AND(=($0, $9), =($17, $8), =($19, $33), =($3, $36), =($36, $40), =($42, $44), =($45, 'EUROPE'), >=($12, 1997-01-01), <($12, +(1997-01-01, 12)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[revenue DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[n_name], select=[n_name, Final_SUM(sum$0) AS revenue])
         +- Exchange(distribution=[hash[n_name]])
            +- LocalHashAggregate(groupBy=[n_name], select=[n_name, Partial_SUM($f1) AS sum$0])
               +- Calc(select=[n_name, *(l_extendedprice, -(1, l_discount)) AS $f1])
                  +- HashJoin(where=[AND(=(l_suppkey, s_suppkey), =(l_orderkey, o_orderkey))], join=[l_orderkey, l_suppkey, l_extendedprice, l_discount, o_orderkey, n_name, s_suppkey], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_suppkey, l_orderkey]])
                     :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_extendedprice, l_discount])
                     +- Exchange(distribution=[hash[s_suppkey, o_orderkey]])
                        +- Calc(select=[o_orderkey, n_name, s_suppkey])
                           +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey, n_name, s_suppkey], joinType=[InnerJoin], build=[right])
                              :- Exchange(distribution=[hash[o_custkey]])
                              :  +- Calc(select=[o_orderkey, o_custkey], where=[AND(>=(o_orderdate, 1997-01-01), <(o_orderdate, 1998-01-01))])
                              :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                              +- Exchange(distribution=[hash[c_custkey]])
                                 +- Calc(select=[c_custkey, n_name, s_suppkey])
                                    +- HashJoin(where=[=(c_nationkey, s_nationkey)], join=[c_custkey, c_nationkey, n_name, s_suppkey, s_nationkey], joinType=[InnerJoin], build=[right])
                                       :- Calc(select=[c_custkey, c_nationkey, n_name])
                                       :  +- HashJoin(where=[=(n_nationkey, c_nationkey)], join=[c_custkey, c_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                                       :     :- Exchange(distribution=[hash[c_nationkey]])
                                       :     :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                                       :     +- Exchange(distribution=[broadcast])
                                       :        +- Calc(select=[n_nationkey, n_name])
                                       :           +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_name, n_regionkey, r_regionkey], joinType=[InnerJoin], build=[right])
                                       :              :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey];filterPredicates=[]]]], fields=[n_nationkey, n_name, n_regionkey])
                                       :              +- Exchange(distribution=[broadcast])
                                       :                 +- Calc(select=[r_regionkey], where=[=(r_name, 'EUROPE')])
                                       :                    +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name];filterPredicates=[]]]], fields=[r_regionkey, r_name])
                                       +- Exchange(distribution=[hash[s_nationkey]])
                                          +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=06, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch6 using 1395599672 as a seed to the RNG

select
  sum(l_extendedprice * l_discount) as revenue
from
  lineitem
where
  l_shipdate >= date '1997-01-01'
  and l_shipdate < date '1997-01-01' + interval '1' year
  and
  l_discount between 0.03 - 0.01 and 0.03 + 0.01
  and l_quantity < 24
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{}], revenue=[SUM($0)])
+- LogicalProject($f0=[*($5, $6)])
   +- LogicalFilter(condition=[AND(>=($10, 1997-01-01), <($10, +(1997-01-01, 12)), >=($6, -(0.03, 0.01)), <=($6, +(0.03, 0.01)), <($4, 24))])
      +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS revenue])
+- Exchange(distribution=[single])
   +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
      +- Calc(select=[*(l_extendedprice, l_discount) AS $f0], where=[AND(>=(l_shipdate, 1997-01-01), <(l_shipdate, 1998-01-01), >=(l_discount, 0.02), <=(l_discount, 0.04), <(l_quantity, 24))])
         +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_quantity, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_quantity, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=06, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch6 using 1395599672 as a seed to the RNG

select
  sum(l_extendedprice * l_discount) as revenue
from
  lineitem
where
  l_shipdate >= date '1997-01-01'
  and l_shipdate < date '1997-01-01' + interval '1' year
  and
  l_discount between 0.03 - 0.01 and 0.03 + 0.01
  and l_quantity < 24
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{}], revenue=[SUM($0)])
+- LogicalProject($f0=[*($5, $6)])
   +- LogicalFilter(condition=[AND(>=($10, 1997-01-01), <($10, +(1997-01-01, 12)), >=($6, -(0.03, 0.01)), <=($6, +(0.03, 0.01)), <($4, 24))])
      +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS revenue])
+- Exchange(distribution=[single])
   +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
      +- Calc(select=[*(l_extendedprice, l_discount) AS $f0], where=[AND(>=(l_shipdate, 1997-01-01), <(l_shipdate, 1998-01-01), >=(l_discount, 0.02), <=(l_discount, 0.04), <(l_quantity, 24))])
         +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_quantity, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_quantity, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=06, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch6 using 1395599672 as a seed to the RNG

select
  sum(l_extendedprice * l_discount) as revenue
from
  lineitem
where
  l_shipdate >= date '1997-01-01'
  and l_shipdate < date '1997-01-01' + interval '1' year
  and
  l_discount between 0.03 - 0.01 and 0.03 + 0.01
  and l_quantity < 24
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{}], revenue=[SUM($0)])
+- LogicalProject($f0=[*($5, $6)])
   +- LogicalFilter(condition=[AND(>=($10, 1997-01-01), <($10, +(1997-01-01, 12)), >=($6, -(0.03, 0.01)), <=($6, +(0.03, 0.01)), <($4, 24))])
      +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS revenue])
+- Exchange(distribution=[single])
   +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
      +- Calc(select=[*(l_extendedprice, l_discount) AS $f0], where=[AND(>=(l_shipdate, 1997-01-01), <(l_shipdate, 1998-01-01), >=(l_discount, 0.02), <=(l_discount, 0.04), <(l_quantity, 24))])
         +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_quantity, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_quantity, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=07, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch7 using 1395599672 as a seed to the RNG
select
  supp_nation,
  cust_nation,
  l_year,
  sum(volume) as revenue
from
  (
    select
      n1.n_name as supp_nation,
      n2.n_name as cust_nation,
      extract(year from l.l_shipdate) as l_year,
      l.l_extendedprice * (1 - l.l_discount) as volume
    from
      supplier s,
      lineitem l,
      orders o,
      customer c,
      nation n1,
      nation n2
    where
      s.s_suppkey = l.l_suppkey
      and o.o_orderkey = l.l_orderkey
      and c.c_custkey = o.o_custkey
      and s.s_nationkey = n1.n_nationkey
      and c.c_nationkey = n2.n_nationkey
      and (
        (n1.n_name = 'EGYPT' and n2.n_name = 'UNITED STATES')
        or (n1.n_name = 'UNITED STATES' and n2.n_name = 'EGYPT')
      )
      and l.l_shipdate between date '1995-01-01' and date '1996-12-31'
  ) as shipping
group by
  supp_nation,
  cust_nation,
  l_year
order by
  supp_nation,
  cust_nation,
  l_year
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], sort2=[$2], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1, 2}], revenue=[SUM($3)])
   +- LogicalProject(supp_nation=[$41], cust_nation=[$45], l_year=[EXTRACT(FLAG(YEAR), $17)], volume=[*($12, -(1, $13))])
      +- LogicalFilter(condition=[AND(=($0, $9), =($23, $7), =($32, $24), =($3, $40), =($35, $44), OR(AND(=($41, 'EGYPT'), =($45, 'UNITED STATES')), AND(=($41, 'UNITED STATES'), =($45, 'EGYPT'))), >=($17, 1995-01-01), <=($17, 1996-12-31))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[supp_nation ASC, cust_nation ASC, l_year ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[supp_nation ASC, cust_nation ASC, l_year ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[supp_nation, cust_nation, l_year], select=[supp_nation, cust_nation, l_year, Final_SUM(sum$0) AS revenue])
         +- Exchange(distribution=[hash[supp_nation, cust_nation, l_year]])
            +- LocalHashAggregate(groupBy=[supp_nation, cust_nation, l_year], select=[supp_nation, cust_nation, l_year, Partial_SUM(volume) AS sum$0])
               +- Calc(select=[n_name AS supp_nation, n_name0 AS cust_nation, EXTRACT(FLAG(YEAR), l_shipdate) AS l_year, *(l_extendedprice, -(1, l_discount)) AS volume])
                  +- HashJoin(where=[AND(=(c_custkey, o_custkey), OR(AND(=(n_name, 'EGYPT'), =(n_name0, 'UNITED STATES')), AND(=(n_name, 'UNITED STATES'), =(n_name0, 'EGYPT'))))], join=[o_custkey, l_extendedprice, l_discount, l_shipdate, n_name, c_custkey, n_name0], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[o_custkey]])
                     :  +- Calc(select=[o_custkey, l_extendedprice, l_discount, l_shipdate, n_name])
                     :     +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey, l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name], joinType=[InnerJoin], build=[right])
                     :        :- Exchange(distribution=[hash[o_orderkey]])
                     :        :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey];filterPredicates=[]]]], fields=[o_orderkey, o_custkey])
                     :        +- Exchange(distribution=[hash[l_orderkey]])
                     :           +- Calc(select=[l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name])
                     :              +- HashJoin(where=[=(s_suppkey, l_suppkey)], join=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                     :                 :- Exchange(distribution=[hash[l_suppkey]])
                     :                 :  +- Calc(select=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate], where=[AND(>=(l_shipdate, 1995-01-01), <=(l_shipdate, 1996-12-31), RUNTIME_FILTER_0(l_suppkey))])
                     :                 :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate])
                     :                 +- Exchange(distribution=[hash[s_suppkey]])
                     :                    +- Calc(select=[s_suppkey, n_name], where=[RUNTIME_FILTER_BUILDER_0(s_suppkey)])
                     :                       +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                     :                          :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                     :                          +- Exchange(distribution=[broadcast])
                     :                             +- Calc(select=[n_nationkey, n_name], where=[OR(=(n_name, 'EGYPT'), =(n_name, 'UNITED STATES'))])
                     :                                +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                     +- Exchange(distribution=[hash[c_custkey]])
                        +- Calc(select=[c_custkey, n_name])
                           +- NestedLoopJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_nationkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                              :- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                              +- Exchange(distribution=[broadcast])
                                 +- Calc(select=[n_nationkey, n_name], where=[OR(=(n_name, 'UNITED STATES'), =(n_name, 'EGYPT'))])
                                    +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=07, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch7 using 1395599672 as a seed to the RNG
select
  supp_nation,
  cust_nation,
  l_year,
  sum(volume) as revenue
from
  (
    select
      n1.n_name as supp_nation,
      n2.n_name as cust_nation,
      extract(year from l.l_shipdate) as l_year,
      l.l_extendedprice * (1 - l.l_discount) as volume
    from
      supplier s,
      lineitem l,
      orders o,
      customer c,
      nation n1,
      nation n2
    where
      s.s_suppkey = l.l_suppkey
      and o.o_orderkey = l.l_orderkey
      and c.c_custkey = o.o_custkey
      and s.s_nationkey = n1.n_nationkey
      and c.c_nationkey = n2.n_nationkey
      and (
        (n1.n_name = 'EGYPT' and n2.n_name = 'UNITED STATES')
        or (n1.n_name = 'UNITED STATES' and n2.n_name = 'EGYPT')
      )
      and l.l_shipdate between date '1995-01-01' and date '1996-12-31'
  ) as shipping
group by
  supp_nation,
  cust_nation,
  l_year
order by
  supp_nation,
  cust_nation,
  l_year
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], sort2=[$2], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1, 2}], revenue=[SUM($3)])
   +- LogicalProject(supp_nation=[$41], cust_nation=[$45], l_year=[EXTRACT(FLAG(YEAR), $17)], volume=[*($12, -(1, $13))])
      +- LogicalFilter(condition=[AND(=($0, $9), =($23, $7), =($32, $24), =($3, $40), =($35, $44), OR(AND(=($41, 'EGYPT'), =($45, 'UNITED STATES')), AND(=($41, 'UNITED STATES'), =($45, 'EGYPT'))), >=($17, 1995-01-01), <=($17, 1996-12-31))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[supp_nation ASC, cust_nation ASC, l_year ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[supp_nation ASC, cust_nation ASC, l_year ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[supp_nation, cust_nation, l_year], select=[supp_nation, cust_nation, l_year, Final_SUM(sum$0) AS revenue])
         +- Exchange(distribution=[hash[supp_nation, cust_nation, l_year]])
            +- LocalHashAggregate(groupBy=[supp_nation, cust_nation, l_year], select=[supp_nation, cust_nation, l_year, Partial_SUM(volume) AS sum$0])
               +- Calc(select=[n_name0 AS supp_nation, n_name AS cust_nation, EXTRACT(FLAG(YEAR), l_shipdate) AS l_year, *(l_extendedprice, -(1, l_discount)) AS volume])
                  +- HashJoin(where=[AND(=(s_suppkey, l_suppkey), OR(AND(=(n_name0, 'EGYPT'), =(n_name, 'UNITED STATES')), AND(=(n_name0, 'UNITED STATES'), =(n_name, 'EGYPT'))))], join=[l_suppkey, l_extendedprice, l_discount, l_shipdate, n_name, s_suppkey, n_name0], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_suppkey]])
                     :  +- Calc(select=[l_suppkey, l_extendedprice, l_discount, l_shipdate, n_name])
                     :     +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_custkey, l_suppkey, l_extendedprice, l_discount, l_shipdate, c_custkey, n_name], joinType=[InnerJoin], build=[right])
                     :        :- Exchange(distribution=[hash[o_custkey]])
                     :        :  +- Calc(select=[o_custkey, l_suppkey, l_extendedprice, l_discount, l_shipdate])
                     :        :     +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey, l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate], joinType=[InnerJoin], build=[left])
                     :        :        :- Exchange(distribution=[hash[o_orderkey]])
                     :        :        :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey];filterPredicates=[]]]], fields=[o_orderkey, o_custkey])
                     :        :        +- Exchange(distribution=[hash[l_orderkey]])
                     :        :           +- Calc(select=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate], where=[AND(>=(l_shipdate, 1995-01-01), <=(l_shipdate, 1996-12-31))])
                     :        :              +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate])
                     :        +- Calc(select=[c_custkey, n_name])
                     :           +- NestedLoopJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_nationkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                     :              :- Exchange(distribution=[hash[c_custkey]])
                     :              :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                     :              +- Exchange(distribution=[broadcast])
                     :                 +- Calc(select=[n_nationkey, n_name], where=[OR(=(n_name, 'UNITED STATES'), =(n_name, 'EGYPT'))])
                     :                    +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                     +- Calc(select=[s_suppkey, n_name])
                        +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                           :- Exchange(distribution=[hash[s_suppkey]])
                           :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                           +- Exchange(distribution=[broadcast])
                              +- Calc(select=[n_nationkey, n_name], where=[OR(=(n_name, 'EGYPT'), =(n_name, 'UNITED STATES'))])
                                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=07, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch7 using 1395599672 as a seed to the RNG
select
  supp_nation,
  cust_nation,
  l_year,
  sum(volume) as revenue
from
  (
    select
      n1.n_name as supp_nation,
      n2.n_name as cust_nation,
      extract(year from l.l_shipdate) as l_year,
      l.l_extendedprice * (1 - l.l_discount) as volume
    from
      supplier s,
      lineitem l,
      orders o,
      customer c,
      nation n1,
      nation n2
    where
      s.s_suppkey = l.l_suppkey
      and o.o_orderkey = l.l_orderkey
      and c.c_custkey = o.o_custkey
      and s.s_nationkey = n1.n_nationkey
      and c.c_nationkey = n2.n_nationkey
      and (
        (n1.n_name = 'EGYPT' and n2.n_name = 'UNITED STATES')
        or (n1.n_name = 'UNITED STATES' and n2.n_name = 'EGYPT')
      )
      and l.l_shipdate between date '1995-01-01' and date '1996-12-31'
  ) as shipping
group by
  supp_nation,
  cust_nation,
  l_year
order by
  supp_nation,
  cust_nation,
  l_year
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], sort2=[$2], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1, 2}], revenue=[SUM($3)])
   +- LogicalProject(supp_nation=[$41], cust_nation=[$45], l_year=[EXTRACT(FLAG(YEAR), $17)], volume=[*($12, -(1, $13))])
      +- LogicalFilter(condition=[AND(=($0, $9), =($23, $7), =($32, $24), =($3, $40), =($35, $44), OR(AND(=($41, 'EGYPT'), =($45, 'UNITED STATES')), AND(=($41, 'UNITED STATES'), =($45, 'EGYPT'))), >=($17, 1995-01-01), <=($17, 1996-12-31))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[supp_nation ASC, cust_nation ASC, l_year ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[supp_nation ASC, cust_nation ASC, l_year ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[supp_nation, cust_nation, l_year], select=[supp_nation, cust_nation, l_year, Final_SUM(sum$0) AS revenue])
         +- Exchange(distribution=[hash[supp_nation, cust_nation, l_year]])
            +- LocalHashAggregate(groupBy=[supp_nation, cust_nation, l_year], select=[supp_nation, cust_nation, l_year, Partial_SUM(volume) AS sum$0])
               +- Calc(select=[n_name0 AS supp_nation, n_name AS cust_nation, EXTRACT(FLAG(YEAR), l_shipdate) AS l_year, *(l_extendedprice, -(1, l_discount)) AS volume])
                  +- HashJoin(where=[AND(=(s_suppkey, l_suppkey), OR(AND(=(n_name0, 'EGYPT'), =(n_name, 'UNITED STATES')), AND(=(n_name0, 'UNITED STATES'), =(n_name, 'EGYPT'))))], join=[l_suppkey, l_extendedprice, l_discount, l_shipdate, n_name, s_suppkey, n_name0], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_suppkey]])
                     :  +- Calc(select=[l_suppkey, l_extendedprice, l_discount, l_shipdate, n_name])
                     :     +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate, o_orderkey, n_name], joinType=[InnerJoin], build=[right])
                     :        :- Exchange(distribution=[hash[l_orderkey]])
                     :        :  +- Calc(select=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate], where=[AND(>=(l_shipdate, 1995-01-01), <=(l_shipdate, 1996-12-31))])
                     :        :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate])
                     :        +- Exchange(distribution=[hash[o_orderkey]])
                     :           +- Calc(select=[o_orderkey, n_name])
                     :              +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey, n_name], joinType=[InnerJoin], build=[right])
                     :                 :- Exchange(distribution=[hash[o_custkey]])
                     :                 :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey];filterPredicates=[]]]], fields=[o_orderkey, o_custkey])
                     :                 +- Calc(select=[c_custkey, n_name])
                     :                    +- NestedLoopJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_nationkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                     :                       :- Exchange(distribution=[hash[c_custkey]])
                     :                       :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                     :                       +- Exchange(distribution=[broadcast])
                     :                          +- Calc(select=[n_nationkey, n_name], where=[OR(=(n_name, 'UNITED STATES'), =(n_name, 'EGYPT'))])
                     :                             +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                     +- Calc(select=[s_suppkey, n_name])
                        +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], build=[right])
                           :- Exchange(distribution=[hash[s_suppkey]])
                           :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                           +- Exchange(distribution=[broadcast])
                              +- Calc(select=[n_nationkey, n_name], where=[OR(=(n_name, 'EGYPT'), =(n_name, 'UNITED STATES'))])
                                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=08, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch8 using 1395599672 as a seed to the RNG
select
  o_year,
  sum(case
    when nation = 'EGYPT' then volume
    else 0
  end) / sum(volume) as mkt_share
from
  (
    select
      extract(year from o.o_orderdate) as o_year,
      l.l_extendedprice * (1 - l.l_discount) as volume,
      n2.n_name as nation
    from
      part p,
      supplier s,
      lineitem l,
      orders o,
      customer c,
      nation n1,
      nation n2,
      region r
    where
      p.p_partkey = l.l_partkey
      and s.s_suppkey = l.l_suppkey
      and l.l_orderkey = o.o_orderkey
      and o.o_custkey = c.c_custkey
      and c.c_nationkey = n1.n_nationkey
      and n1.n_regionkey = r.r_regionkey
      and r.r_name = 'MIDDLE EAST'
      and s.s_nationkey = n2.n_nationkey
      and o.o_orderdate between date '1995-01-01' and date '1996-12-31'
      and p.p_type = 'PROMO BRUSHED COPPER'
  ) as all_nations
group by
  o_year
order by
  o_year
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(o_year=[$0], mkt_share=[/($1, $2)])
   +- LogicalAggregate(group=[{0}], agg#0=[SUM($1)], agg#1=[SUM($2)])
      +- LogicalProject(o_year=[$0], $f1=[CASE(=($2, 'EGYPT'), $1, 0)], volume=[$1])
         +- LogicalProject(o_year=[EXTRACT(FLAG(YEAR), $36)], volume=[*($21, -(1, $22))], nation=[$54])
            +- LogicalFilter(condition=[AND(=($0, $17), =($9, $18), =($16, $32), =($33, $41), =($44, $49), =($51, $57), =($58, 'MIDDLE EAST'), =($12, $53), >=($36, 1995-01-01), <=($36, 1996-12-31), =($4, 'PROMO BRUSHED COPPER'))])
               +- LogicalJoin(condition=[true], joinType=[inner])
                  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
                  :  :  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
                  :  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
                  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
                  :  :  :  +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
                  :  :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
                  :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
                  +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[o_year, /($f1, $f2) AS mkt_share])
+- SortLimit(orderBy=[o_year ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[o_year ASC], offset=[0], limit=[200], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[o_year], select=[o_year, Final_SUM(sum$0) AS $f1, Final_SUM(sum$1) AS $f2])
            +- Exchange(distribution=[hash[o_year]])
               +- LocalHashAggregate(groupBy=[o_year], select=[o_year, Partial_SUM($f1) AS sum$0, Partial_SUM(volume) AS sum$1])
                  +- Calc(select=[EXTRACT(FLAG(YEAR), o_orderdate) AS o_year, CASE(=(n_name, 'EGYPT'), *(l_extendedprice, -(1, l_discount)), 0) AS $f1, *(l_extendedprice, -(1, l_discount)) AS volume])
                     +- NestedLoopJoin(where=[=(c_nationkey, n_nationkey)], join=[c_nationkey, o_orderdate, l_extendedprice, l_discount, n_name, n_nationkey], joinType=[InnerJoin], build=[right])
                        :- Calc(select=[c_nationkey, o_orderdate, l_extendedprice, l_discount, n_name])
                        :  +- HashJoin(where=[=(o_custkey, c_custkey)], join=[c_custkey, c_nationkey, o_custkey, o_orderdate, l_extendedprice, l_discount, n_name], joinType=[InnerJoin], build=[right])
                        :     :- Exchange(distribution=[hash[c_custkey]])
                        :     :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                        :     +- Exchange(distribution=[hash[o_custkey]])
                        :        +- Calc(select=[o_custkey, o_orderdate, l_extendedprice, l_discount, n_name])
                        :           +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[o_orderkey, o_custkey, o_orderdate, l_orderkey, l_extendedprice, l_discount, n_name], joinType=[InnerJoin], build=[right])
                        :              :- Exchange(distribution=[hash[o_orderkey]])
                        :              :  +- Calc(select=[o_orderkey, o_custkey, o_orderdate], where=[AND(>=(o_orderdate, 1995-01-01), <=(o_orderdate, 1996-12-31))])
                        :              :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                        :              +- Exchange(distribution=[hash[l_orderkey]])
                        :                 +- Calc(select=[l_orderkey, l_extendedprice, l_discount, n_name])
                        :                    +- HashJoin(where=[=(s_suppkey, l_suppkey)], join=[l_orderkey, l_suppkey, l_extendedprice, l_discount, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                        :                       :- Exchange(distribution=[hash[l_suppkey]])
                        :                       :  +- Calc(select=[l_orderkey, l_suppkey, l_extendedprice, l_discount])
                        :                       :     +- HashJoin(where=[=(p_partkey, l_partkey)], join=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount, p_partkey], joinType=[InnerJoin], build=[right])
                        :                       :        :- Exchange(distribution=[hash[l_partkey]])
                        :                       :        :  +- Calc(select=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount], where=[RUNTIME_FILTER_0(l_partkey)])
                        :                       :        :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount])
                        :                       :        +- Exchange(distribution=[hash[p_partkey]])
                        :                       :           +- Calc(select=[p_partkey], where=[AND(=(p_type, 'PROMO BRUSHED COPPER'), RUNTIME_FILTER_BUILDER_0(p_partkey))])
                        :                       :              +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_type];filterPredicates=[]]]], fields=[p_partkey, p_type])
                        :                       +- Exchange(distribution=[hash[s_suppkey]])
                        :                          +- Calc(select=[s_suppkey, n_name])
                        :                             +- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                        :                                :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                        :                                +- Exchange(distribution=[broadcast])
                        :                                   +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                        +- Exchange(distribution=[broadcast])
                           +- Calc(select=[n_nationkey])
                              +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_regionkey, r_regionkey], joinType=[InnerJoin], build=[right])
                                 :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_regionkey];filterPredicates=[]]]], fields=[n_nationkey, n_regionkey])
                                 +- Exchange(distribution=[broadcast])
                                    +- Calc(select=[r_regionkey], where=[=(r_name, 'MIDDLE EAST')])
                                       +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name];filterPredicates=[]]]], fields=[r_regionkey, r_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=08, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch8 using 1395599672 as a seed to the RNG
select
  o_year,
  sum(case
    when nation = 'EGYPT' then volume
    else 0
  end) / sum(volume) as mkt_share
from
  (
    select
      extract(year from o.o_orderdate) as o_year,
      l.l_extendedprice * (1 - l.l_discount) as volume,
      n2.n_name as nation
    from
      part p,
      supplier s,
      lineitem l,
      orders o,
      customer c,
      nation n1,
      nation n2,
      region r
    where
      p.p_partkey = l.l_partkey
      and s.s_suppkey = l.l_suppkey
      and l.l_orderkey = o.o_orderkey
      and o.o_custkey = c.c_custkey
      and c.c_nationkey = n1.n_nationkey
      and n1.n_regionkey = r.r_regionkey
      and r.r_name = 'MIDDLE EAST'
      and s.s_nationkey = n2.n_nationkey
      and o.o_orderdate between date '1995-01-01' and date '1996-12-31'
      and p.p_type = 'PROMO BRUSHED COPPER'
  ) as all_nations
group by
  o_year
order by
  o_year
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(o_year=[$0], mkt_share=[/($1, $2)])
   +- LogicalAggregate(group=[{0}], agg#0=[SUM($1)], agg#1=[SUM($2)])
      +- LogicalProject(o_year=[$0], $f1=[CASE(=($2, 'EGYPT'), $1, 0)], volume=[$1])
         +- LogicalProject(o_year=[EXTRACT(FLAG(YEAR), $36)], volume=[*($21, -(1, $22))], nation=[$54])
            +- LogicalFilter(condition=[AND(=($0, $17), =($9, $18), =($16, $32), =($33, $41), =($44, $49), =($51, $57), =($58, 'MIDDLE EAST'), =($12, $53), >=($36, 1995-01-01), <=($36, 1996-12-31), =($4, 'PROMO BRUSHED COPPER'))])
               +- LogicalJoin(condition=[true], joinType=[inner])
                  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
                  :  :  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
                  :  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
                  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
                  :  :  :  +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
                  :  :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
                  :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
                  +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[o_year, /($f1, $f2) AS mkt_share])
+- SortLimit(orderBy=[o_year ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[o_year ASC], offset=[0], limit=[200], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[o_year], select=[o_year, Final_SUM(sum$0) AS $f1, Final_SUM(sum$1) AS $f2])
            +- Exchange(distribution=[hash[o_year]])
               +- LocalHashAggregate(groupBy=[o_year], select=[o_year, Partial_SUM($f1) AS sum$0, Partial_SUM(volume) AS sum$1])
                  +- Calc(select=[EXTRACT(FLAG(YEAR), o_orderdate) AS o_year, CASE(=(n_name, 'EGYPT'), *(l_extendedprice, -(1, l_discount)), 0) AS $f1, *(l_extendedprice, -(1, l_discount)) AS volume])
                     +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, n_name, o_orderkey, o_orderdate], joinType=[InnerJoin], build=[left])
                        :- Exchange(distribution=[hash[l_orderkey]])
                        :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount, n_name])
                        :     +- HashJoin(where=[=(p_partkey, l_partkey)], join=[l_orderkey, l_partkey, l_extendedprice, l_discount, n_name, p_partkey], joinType=[InnerJoin], build=[right])
                        :        :- Exchange(distribution=[hash[l_partkey]])
                        :        :  +- Calc(select=[l_orderkey, l_partkey, l_extendedprice, l_discount, n_name])
                        :        :     +- HashJoin(where=[=(s_suppkey, l_suppkey)], join=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                        :        :        :- Exchange(distribution=[hash[l_suppkey]])
                        :        :        :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount])
                        :        :        +- Calc(select=[s_suppkey, n_name])
                        :        :           +- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                        :        :              :- Exchange(distribution=[hash[s_suppkey]])
                        :        :              :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                        :        :              +- Exchange(distribution=[broadcast])
                        :        :                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                        :        +- Exchange(distribution=[hash[p_partkey]])
                        :           +- Calc(select=[p_partkey], where=[=(p_type, 'PROMO BRUSHED COPPER')])
                        :              +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_type];filterPredicates=[]]]], fields=[p_partkey, p_type])
                        +- Exchange(distribution=[hash[o_orderkey]])
                           +- Calc(select=[o_orderkey, o_orderdate])
                              +- HashJoin(where=[=(o_custkey, c_custkey)], join=[o_orderkey, o_custkey, o_orderdate, c_custkey], joinType=[InnerJoin], build=[right])
                                 :- Exchange(distribution=[hash[o_custkey]])
                                 :  +- Calc(select=[o_orderkey, o_custkey, o_orderdate], where=[AND(>=(o_orderdate, 1995-01-01), <=(o_orderdate, 1996-12-31))])
                                 :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                                 +- Exchange(distribution=[hash[c_custkey]])
                                    +- Calc(select=[c_custkey])
                                       +- HashJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_nationkey, n_nationkey], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                                          :- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                                          +- Exchange(distribution=[broadcast])
                                             +- Calc(select=[n_nationkey])
                                                +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_regionkey, r_regionkey], joinType=[InnerJoin], build=[right])
                                                   :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_regionkey];filterPredicates=[]]]], fields=[n_nationkey, n_regionkey])
                                                   +- Exchange(distribution=[broadcast])
                                                      +- Calc(select=[r_regionkey], where=[=(r_name, 'MIDDLE EAST')])
                                                         +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name];filterPredicates=[]]]], fields=[r_regionkey, r_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=08, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch8 using 1395599672 as a seed to the RNG
select
  o_year,
  sum(case
    when nation = 'EGYPT' then volume
    else 0
  end) / sum(volume) as mkt_share
from
  (
    select
      extract(year from o.o_orderdate) as o_year,
      l.l_extendedprice * (1 - l.l_discount) as volume,
      n2.n_name as nation
    from
      part p,
      supplier s,
      lineitem l,
      orders o,
      customer c,
      nation n1,
      nation n2,
      region r
    where
      p.p_partkey = l.l_partkey
      and s.s_suppkey = l.l_suppkey
      and l.l_orderkey = o.o_orderkey
      and o.o_custkey = c.c_custkey
      and c.c_nationkey = n1.n_nationkey
      and n1.n_regionkey = r.r_regionkey
      and r.r_name = 'MIDDLE EAST'
      and s.s_nationkey = n2.n_nationkey
      and o.o_orderdate between date '1995-01-01' and date '1996-12-31'
      and p.p_type = 'PROMO BRUSHED COPPER'
  ) as all_nations
group by
  o_year
order by
  o_year
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(o_year=[$0], mkt_share=[/($1, $2)])
   +- LogicalAggregate(group=[{0}], agg#0=[SUM($1)], agg#1=[SUM($2)])
      +- LogicalProject(o_year=[$0], $f1=[CASE(=($2, 'EGYPT'), $1, 0)], volume=[$1])
         +- LogicalProject(o_year=[EXTRACT(FLAG(YEAR), $36)], volume=[*($21, -(1, $22))], nation=[$54])
            +- LogicalFilter(condition=[AND(=($0, $17), =($9, $18), =($16, $32), =($33, $41), =($44, $49), =($51, $57), =($58, 'MIDDLE EAST'), =($12, $53), >=($36, 1995-01-01), <=($36, 1996-12-31), =($4, 'PROMO BRUSHED COPPER'))])
               +- LogicalJoin(condition=[true], joinType=[inner])
                  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
                  :  :  :  :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
                  :  :  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
                  :  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
                  :  :  :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
                  :  :  :  +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
                  :  :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
                  :  +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
                  +- LogicalTableScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name, r_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[o_year, /($f1, $f2) AS mkt_share])
+- SortLimit(orderBy=[o_year ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[o_year ASC], offset=[0], limit=[200], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[o_year], select=[o_year, Final_SUM(sum$0) AS $f1, Final_SUM(sum$1) AS $f2])
            +- Exchange(distribution=[hash[o_year]])
               +- LocalHashAggregate(groupBy=[o_year], select=[o_year, Partial_SUM($f1) AS sum$0, Partial_SUM(volume) AS sum$1])
                  +- Calc(select=[EXTRACT(FLAG(YEAR), o_orderdate) AS o_year, CASE(=(n_name, 'EGYPT'), *(l_extendedprice, -(1, l_discount)), 0) AS $f1, *(l_extendedprice, -(1, l_discount)) AS volume])
                     +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, n_name, o_orderkey, o_orderdate], joinType=[InnerJoin], build=[left])
                        :- Exchange(distribution=[hash[l_orderkey]])
                        :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount, n_name])
                        :     +- HashJoin(where=[=(p_partkey, l_partkey)], join=[l_orderkey, l_partkey, l_extendedprice, l_discount, n_name, p_partkey], joinType=[InnerJoin], build=[right])
                        :        :- Exchange(distribution=[hash[l_partkey]])
                        :        :  +- Calc(select=[l_orderkey, l_partkey, l_extendedprice, l_discount, n_name])
                        :        :     +- HashJoin(where=[=(s_suppkey, l_suppkey)], join=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                        :        :        :- Exchange(distribution=[hash[l_suppkey]])
                        :        :        :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount])
                        :        :        +- Calc(select=[s_suppkey, n_name])
                        :        :           +- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                        :        :              :- Exchange(distribution=[hash[s_suppkey]])
                        :        :              :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                        :        :              +- Exchange(distribution=[broadcast])
                        :        :                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                        :        +- Exchange(distribution=[hash[p_partkey]])
                        :           +- Calc(select=[p_partkey], where=[=(p_type, 'PROMO BRUSHED COPPER')])
                        :              +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_type];filterPredicates=[]]]], fields=[p_partkey, p_type])
                        +- Exchange(distribution=[hash[o_orderkey]])
                           +- Calc(select=[o_orderkey, o_orderdate])
                              +- HashJoin(where=[=(o_custkey, c_custkey)], join=[o_orderkey, o_custkey, o_orderdate, c_custkey], joinType=[InnerJoin], build=[right])
                                 :- Exchange(distribution=[hash[o_custkey]])
                                 :  +- Calc(select=[o_orderkey, o_custkey, o_orderdate], where=[AND(>=(o_orderdate, 1995-01-01), <=(o_orderdate, 1996-12-31))])
                                 :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                                 +- Exchange(distribution=[hash[c_custkey]])
                                    +- Calc(select=[c_custkey])
                                       +- HashJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_nationkey, n_nationkey], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                                          :- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_nationkey];filterPredicates=[]]]], fields=[c_custkey, c_nationkey])
                                          +- Exchange(distribution=[broadcast])
                                             +- Calc(select=[n_nationkey])
                                                +- NestedLoopJoin(where=[=(n_regionkey, r_regionkey)], join=[n_nationkey, n_regionkey, r_regionkey], joinType=[InnerJoin], build=[right])
                                                   :- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_regionkey];filterPredicates=[]]]], fields=[n_nationkey, n_regionkey])
                                                   +- Exchange(distribution=[broadcast])
                                                      +- Calc(select=[r_regionkey], where=[=(r_name, 'MIDDLE EAST')])
                                                         +- TableSourceScan(table=[[builtin, default, region, source: [TestParquetTableSource -> selectedFields=[r_regionkey, r_name];filterPredicates=[]]]], fields=[r_regionkey, r_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=09, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch9 using 1395599672 as a seed to the RNG
select
  nation,
  o_year,
  sum(amount) as sum_profit
from
  (
    select
      n.n_name as nation,
      extract(year from o.o_orderdate) as o_year,
      l.l_extendedprice * (1 - l.l_discount) - ps.ps_supplycost * l.l_quantity as amount
    from
      part p,
      supplier s,
      lineitem l,
      partsupp ps,
      orders o,
      nation n
    where
      s.s_suppkey = l.l_suppkey
      and ps.ps_suppkey = l.l_suppkey
      and ps.ps_partkey = l.l_partkey
      and p.p_partkey = l.l_partkey
      and o.o_orderkey = l.l_orderkey
      and s.s_nationkey = n.n_nationkey
      and p.p_name like '%yellow%'
  ) as profit
group by
  nation,
  o_year
order by
  nation,
  o_year desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC-nulls-first], dir1=[DESC-nulls-last])
+- LogicalAggregate(group=[{0, 1}], sum_profit=[SUM($2)])
   +- LogicalProject(nation=[$47], o_year=[EXTRACT(FLAG(YEAR), $41)], amount=[-(*($21, -(1, $22)), *($35, $20))])
      +- LogicalFilter(condition=[AND(=($9, $18), =($33, $18), =($32, $17), =($0, $17), =($37, $16), =($12, $46), LIKE($1, '%yellow%'))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[nation ASC, o_year DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[nation ASC, o_year DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[nation, o_year], select=[nation, o_year, Final_SUM(sum$0) AS sum_profit])
         +- Exchange(distribution=[hash[nation, o_year]])
            +- LocalHashAggregate(groupBy=[nation, o_year], select=[nation, o_year, Partial_SUM(amount) AS sum$0])
               +- Calc(select=[n_name AS nation, EXTRACT(FLAG(YEAR), o_orderdate) AS o_year, -(*(l_extendedprice, -(1, l_discount)), *(ps_supplycost, l_quantity)) AS amount])
                  +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_orderdate, ps_supplycost, l_orderkey, l_quantity, l_extendedprice, l_discount, n_name], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_orderdate])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[ps_supplycost, l_orderkey, l_quantity, l_extendedprice, l_discount, n_name])
                           +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_suppkey, ps_supplycost, l_orderkey, l_quantity, l_extendedprice, l_discount, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                              :- Calc(select=[ps_suppkey, ps_supplycost, l_orderkey, l_quantity, l_extendedprice, l_discount])
                              :  +- HashJoin(where=[AND(=(ps_suppkey, l_suppkey), =(ps_partkey, l_partkey))], join=[ps_partkey, ps_suppkey, ps_supplycost, l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount], joinType=[InnerJoin], build=[right])
                              :     :- Exchange(distribution=[hash[ps_suppkey]])
                              :     :  +- Calc(select=[ps_partkey, ps_suppkey, ps_supplycost], where=[RUNTIME_FILTER_0(ps_partkey)])
                              :     :     +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_supplycost];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_supplycost])
                              :     +- Exchange(distribution=[hash[l_suppkey]])
                              :        +- Calc(select=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount])
                              :           +- HashJoin(where=[=(p_partkey, l_partkey)], join=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, p_partkey], joinType=[InnerJoin], build=[right])
                              :              :- Exchange(distribution=[hash[l_partkey]])
                              :              :  +- Calc(select=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount], where=[RUNTIME_FILTER_0(l_partkey)])
                              :              :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount])
                              :              +- Exchange(distribution=[hash[p_partkey]])
                              :                 +- Calc(select=[p_partkey], where=[AND(LIKE(p_name, '%yellow%'), RUNTIME_FILTER_BUILDER_0(p_partkey))])
                              :                    +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name];filterPredicates=[]]]], fields=[p_partkey, p_name])
                              +- Exchange(distribution=[hash[s_suppkey]])
                                 +- Calc(select=[s_suppkey, n_name])
                                    +- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                                       :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                                       +- Exchange(distribution=[broadcast])
                                          +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=09, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch9 using 1395599672 as a seed to the RNG
select
  nation,
  o_year,
  sum(amount) as sum_profit
from
  (
    select
      n.n_name as nation,
      extract(year from o.o_orderdate) as o_year,
      l.l_extendedprice * (1 - l.l_discount) - ps.ps_supplycost * l.l_quantity as amount
    from
      part p,
      supplier s,
      lineitem l,
      partsupp ps,
      orders o,
      nation n
    where
      s.s_suppkey = l.l_suppkey
      and ps.ps_suppkey = l.l_suppkey
      and ps.ps_partkey = l.l_partkey
      and p.p_partkey = l.l_partkey
      and o.o_orderkey = l.l_orderkey
      and s.s_nationkey = n.n_nationkey
      and p.p_name like '%yellow%'
  ) as profit
group by
  nation,
  o_year
order by
  nation,
  o_year desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC-nulls-first], dir1=[DESC-nulls-last])
+- LogicalAggregate(group=[{0, 1}], sum_profit=[SUM($2)])
   +- LogicalProject(nation=[$47], o_year=[EXTRACT(FLAG(YEAR), $41)], amount=[-(*($21, -(1, $22)), *($35, $20))])
      +- LogicalFilter(condition=[AND(=($9, $18), =($33, $18), =($32, $17), =($0, $17), =($37, $16), =($12, $46), LIKE($1, '%yellow%'))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[nation ASC, o_year DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[nation ASC, o_year DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[nation, o_year], select=[nation, o_year, Final_SUM(sum$0) AS sum_profit])
         +- Exchange(distribution=[hash[nation, o_year]])
            +- LocalHashAggregate(groupBy=[nation, o_year], select=[nation, o_year, Partial_SUM(amount) AS sum$0])
               +- Calc(select=[n_name AS nation, EXTRACT(FLAG(YEAR), o_orderdate) AS o_year, -(*(l_extendedprice, -(1, l_discount)), *(ps_supplycost, l_quantity)) AS amount])
                  +- HashJoin(where=[AND(=(l_suppkey, s_suppkey), =(l_partkey, ps_partkey))], join=[l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, o_orderdate, ps_partkey, ps_supplycost, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_suppkey, l_partkey]])
                     :  +- Calc(select=[l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, o_orderdate])
                     :     +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, o_orderkey, o_orderdate], joinType=[InnerJoin], build=[right])
                     :        :- Exchange(distribution=[hash[l_orderkey]])
                     :        :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount])
                     :        +- Exchange(distribution=[hash[o_orderkey]])
                     :           +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_orderdate])
                     +- Exchange(distribution=[hash[s_suppkey, ps_partkey]])
                        +- Calc(select=[ps_partkey, ps_supplycost, s_suppkey, n_name])
                           +- HashJoin(where=[=(ps_partkey, p_partkey)], join=[ps_partkey, ps_supplycost, s_suppkey, n_name, p_partkey], joinType=[InnerJoin], build=[right])
                              :- Exchange(distribution=[hash[ps_partkey]])
                              :  +- Calc(select=[ps_partkey, ps_supplycost, s_suppkey, n_name])
                              :     +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_partkey, ps_suppkey, ps_supplycost, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                              :        :- Exchange(distribution=[hash[ps_suppkey]])
                              :        :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_supplycost];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_supplycost])
                              :        +- Calc(select=[s_suppkey, n_name])
                              :           +- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                              :              :- Exchange(distribution=[hash[s_suppkey]])
                              :              :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                              :              +- Exchange(distribution=[broadcast])
                              :                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                              +- Exchange(distribution=[hash[p_partkey]])
                                 +- Calc(select=[p_partkey], where=[LIKE(p_name, '%yellow%')])
                                    +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name];filterPredicates=[]]]], fields=[p_partkey, p_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=09, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch9 using 1395599672 as a seed to the RNG
select
  nation,
  o_year,
  sum(amount) as sum_profit
from
  (
    select
      n.n_name as nation,
      extract(year from o.o_orderdate) as o_year,
      l.l_extendedprice * (1 - l.l_discount) - ps.ps_supplycost * l.l_quantity as amount
    from
      part p,
      supplier s,
      lineitem l,
      partsupp ps,
      orders o,
      nation n
    where
      s.s_suppkey = l.l_suppkey
      and ps.ps_suppkey = l.l_suppkey
      and ps.ps_partkey = l.l_partkey
      and p.p_partkey = l.l_partkey
      and o.o_orderkey = l.l_orderkey
      and s.s_nationkey = n.n_nationkey
      and p.p_name like '%yellow%'
  ) as profit
group by
  nation,
  o_year
order by
  nation,
  o_year desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC-nulls-first], dir1=[DESC-nulls-last])
+- LogicalAggregate(group=[{0, 1}], sum_profit=[SUM($2)])
   +- LogicalProject(nation=[$47], o_year=[EXTRACT(FLAG(YEAR), $41)], amount=[-(*($21, -(1, $22)), *($35, $20))])
      +- LogicalFilter(condition=[AND(=($9, $18), =($33, $18), =($32, $17), =($0, $17), =($37, $16), =($12, $46), LIKE($1, '%yellow%'))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :  :  :- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
            :  :  :  :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[nation ASC, o_year DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[nation ASC, o_year DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[nation, o_year], select=[nation, o_year, Final_SUM(sum$0) AS sum_profit])
         +- Exchange(distribution=[hash[nation, o_year]])
            +- LocalHashAggregate(groupBy=[nation, o_year], select=[nation, o_year, Partial_SUM(amount) AS sum$0])
               +- Calc(select=[n_name AS nation, EXTRACT(FLAG(YEAR), o_orderdate) AS o_year, -(*(l_extendedprice, -(1, l_discount)), *(ps_supplycost, l_quantity)) AS amount])
                  +- HashJoin(where=[AND(=(l_suppkey, s_suppkey), =(l_partkey, ps_partkey))], join=[l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, o_orderdate, ps_partkey, ps_supplycost, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_suppkey, l_partkey]])
                     :  +- Calc(select=[l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, o_orderdate])
                     :     +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, o_orderkey, o_orderdate], joinType=[InnerJoin], build=[right])
                     :        :- Exchange(distribution=[hash[l_orderkey]])
                     :        :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount];filterPredicates=[]]]], fields=[l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount])
                     :        +- Exchange(distribution=[hash[o_orderkey]])
                     :           +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_orderdate])
                     +- Exchange(distribution=[hash[s_suppkey, ps_partkey]])
                        +- Calc(select=[ps_partkey, ps_supplycost, s_suppkey, n_name])
                           +- HashJoin(where=[=(ps_partkey, p_partkey)], join=[ps_partkey, ps_supplycost, s_suppkey, n_name, p_partkey], joinType=[InnerJoin], build=[right])
                              :- Exchange(distribution=[hash[ps_partkey]])
                              :  +- Calc(select=[ps_partkey, ps_supplycost, s_suppkey, n_name])
                              :     +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_partkey, ps_suppkey, ps_supplycost, s_suppkey, n_name], joinType=[InnerJoin], build=[right])
                              :        :- Exchange(distribution=[hash[ps_suppkey]])
                              :        :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_supplycost];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_supplycost])
                              :        +- Calc(select=[s_suppkey, n_name])
                              :           +- HashJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                              :              :- Exchange(distribution=[hash[s_suppkey]])
                              :              :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                              :              +- Exchange(distribution=[broadcast])
                              :                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                              +- Exchange(distribution=[hash[p_partkey]])
                                 +- Calc(select=[p_partkey], where=[LIKE(p_name, '%yellow%')])
                                    +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name];filterPredicates=[]]]], fields=[p_partkey, p_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=10, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch10 using 1395599672 as a seed to the RNG
select
  c.c_custkey,
  c.c_name,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue,
  c.c_acctbal,
  n.n_name,
  c.c_address,
  c.c_phone,
  c.c_comment
from
  customer c,
  orders o,
  lineitem l,
  nation n
where
  c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and o.o_orderdate >= date '1994-03-01'
  and o.o_orderdate < date '1994-03-01' + interval '3' month
  and l.l_returnflag = 'R'
  and c.c_nationkey = n.n_nationkey
group by
  c.c_custkey,
  c.c_name,
  c.c_acctbal,
  c.c_phone,
  n.n_name,
  c.c_address,
  c.c_comment
order by
  revenue desc
limit 20
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$2], dir0=[DESC-nulls-last], fetch=[20])
+- LogicalProject(c_custkey=[$0], c_name=[$1], revenue=[$7], c_acctbal=[$2], n_name=[$4], c_address=[$5], c_phone=[$3], c_comment=[$6])
   +- LogicalAggregate(group=[{0, 1, 2, 3, 4, 5, 6}], revenue=[SUM($7)])
      +- LogicalProject(c_custkey=[$0], c_name=[$1], c_acctbal=[$5], c_phone=[$4], n_name=[$34], c_address=[$2], c_comment=[$7], $f7=[*($22, -(1, $23))])
         +- LogicalFilter(condition=[AND(=($0, $9), =($17, $8), >=($12, 1994-03-01), <($12, +(1994-03-01, 3)), =($25, 'R'), =($3, $33))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalJoin(condition=[true], joinType=[inner])
               :  :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment])
+- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[20], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[20], global=[false])
         +- HashAggregate(isMerge=[false], groupBy=[c_custkey, n_name], auxGrouping=[c_name, c_acctbal, c_phone, c_address, c_comment], select=[c_custkey, n_name, c_name, c_acctbal, c_phone, c_address, c_comment, SUM($f7) AS revenue])
            +- Exchange(distribution=[hash[c_custkey, n_name]])
               +- Calc(select=[c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment, *(l_extendedprice, -(1, l_discount)) AS $f7])
                  +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, o_orderkey, n_name], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_orderkey]])
                     :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount], where=[AND(=(l_returnflag, 'R'), RUNTIME_FILTER_1(l_orderkey))])
                     :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_extendedprice, l_discount, l_returnflag];filterPredicates=[]]]], fields=[l_orderkey, l_extendedprice, l_discount, l_returnflag])
                     +- Exchange(distribution=[hash[o_orderkey]])
                        +- Calc(select=[c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, o_orderkey, n_name], where=[RUNTIME_FILTER_BUILDER_1(o_orderkey)])
                           +- HashJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, o_orderkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                              :- Calc(select=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, o_orderkey])
                              :  +- HashJoin(where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
                              :     :- Exchange(distribution=[hash[c_custkey]])
                              :     :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment];filterPredicates=[]]]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment])
                              :     +- Exchange(distribution=[hash[o_custkey]])
                              :        +- Calc(select=[o_orderkey, o_custkey], where=[AND(>=(o_orderdate, 1994-03-01), <(o_orderdate, 1994-06-01))])
                              :           +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                              +- Exchange(distribution=[broadcast])
                                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=10, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch10 using 1395599672 as a seed to the RNG
select
  c.c_custkey,
  c.c_name,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue,
  c.c_acctbal,
  n.n_name,
  c.c_address,
  c.c_phone,
  c.c_comment
from
  customer c,
  orders o,
  lineitem l,
  nation n
where
  c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and o.o_orderdate >= date '1994-03-01'
  and o.o_orderdate < date '1994-03-01' + interval '3' month
  and l.l_returnflag = 'R'
  and c.c_nationkey = n.n_nationkey
group by
  c.c_custkey,
  c.c_name,
  c.c_acctbal,
  c.c_phone,
  n.n_name,
  c.c_address,
  c.c_comment
order by
  revenue desc
limit 20
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$2], dir0=[DESC-nulls-last], fetch=[20])
+- LogicalProject(c_custkey=[$0], c_name=[$1], revenue=[$7], c_acctbal=[$2], n_name=[$4], c_address=[$5], c_phone=[$3], c_comment=[$6])
   +- LogicalAggregate(group=[{0, 1, 2, 3, 4, 5, 6}], revenue=[SUM($7)])
      +- LogicalProject(c_custkey=[$0], c_name=[$1], c_acctbal=[$5], c_phone=[$4], n_name=[$34], c_address=[$2], c_comment=[$7], $f7=[*($22, -(1, $23))])
         +- LogicalFilter(condition=[AND(=($0, $9), =($17, $8), >=($12, 1994-03-01), <($12, +(1994-03-01, 3)), =($25, 'R'), =($3, $33))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalJoin(condition=[true], joinType=[inner])
               :  :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment])
+- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[20], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[20], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[c_custkey, n_name], auxGrouping=[c_name, c_acctbal, c_phone, c_address, c_comment], select=[c_custkey, n_name, c_name, c_acctbal, c_phone, c_address, c_comment, Final_SUM(sum$0) AS revenue])
            +- Exchange(distribution=[hash[c_custkey, n_name]])
               +- LocalHashAggregate(groupBy=[c_custkey, n_name], auxGrouping=[c_name, c_acctbal, c_phone, c_address, c_comment], select=[c_custkey, n_name, c_name, c_acctbal, c_phone, c_address, c_comment, Partial_SUM($f7) AS sum$0])
                  +- Calc(select=[c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment, *(l_extendedprice, -(1, l_discount)) AS $f7])
                     +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, o_orderkey, c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, n_name], joinType=[InnerJoin], build=[left])
                        :- Exchange(distribution=[hash[l_orderkey]])
                        :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount], where=[=(l_returnflag, 'R')])
                        :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_extendedprice, l_discount, l_returnflag];filterPredicates=[]]]], fields=[l_orderkey, l_extendedprice, l_discount, l_returnflag])
                        +- Exchange(distribution=[hash[o_orderkey]])
                           +- Calc(select=[o_orderkey, c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, n_name])
                              +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, n_name], joinType=[InnerJoin], build=[left])
                                 :- Exchange(distribution=[hash[o_custkey]])
                                 :  +- Calc(select=[o_orderkey, o_custkey], where=[AND(>=(o_orderdate, 1994-03-01), <(o_orderdate, 1994-06-01))])
                                 :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                                 +- Calc(select=[c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, n_name])
                                    +- HashJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                                       :- Exchange(distribution=[hash[c_custkey]])
                                       :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment];filterPredicates=[]]]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment])
                                       +- Exchange(distribution=[broadcast])
                                          +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=10, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch10 using 1395599672 as a seed to the RNG
select
  c.c_custkey,
  c.c_name,
  sum(l.l_extendedprice * (1 - l.l_discount)) as revenue,
  c.c_acctbal,
  n.n_name,
  c.c_address,
  c.c_phone,
  c.c_comment
from
  customer c,
  orders o,
  lineitem l,
  nation n
where
  c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and o.o_orderdate >= date '1994-03-01'
  and o.o_orderdate < date '1994-03-01' + interval '3' month
  and l.l_returnflag = 'R'
  and c.c_nationkey = n.n_nationkey
group by
  c.c_custkey,
  c.c_name,
  c.c_acctbal,
  c.c_phone,
  n.n_name,
  c.c_address,
  c.c_comment
order by
  revenue desc
limit 20
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$2], dir0=[DESC-nulls-last], fetch=[20])
+- LogicalProject(c_custkey=[$0], c_name=[$1], revenue=[$7], c_acctbal=[$2], n_name=[$4], c_address=[$5], c_phone=[$3], c_comment=[$6])
   +- LogicalAggregate(group=[{0, 1, 2, 3, 4, 5, 6}], revenue=[SUM($7)])
      +- LogicalProject(c_custkey=[$0], c_name=[$1], c_acctbal=[$5], c_phone=[$4], n_name=[$34], c_address=[$2], c_comment=[$7], $f7=[*($22, -(1, $23))])
         +- LogicalFilter(condition=[AND(=($0, $9), =($17, $8), >=($12, 1994-03-01), <($12, +(1994-03-01, 3)), =($25, 'R'), =($3, $33))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalJoin(condition=[true], joinType=[inner])
               :  :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               :  :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment])
+- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[20], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[revenue DESC], offset=[0], limit=[20], global=[false])
         +- HashAggregate(isMerge=[true], groupBy=[c_custkey, n_name], auxGrouping=[c_name, c_acctbal, c_phone, c_address, c_comment], select=[c_custkey, n_name, c_name, c_acctbal, c_phone, c_address, c_comment, Final_SUM(sum$0) AS revenue])
            +- Exchange(distribution=[hash[c_custkey, n_name]])
               +- LocalHashAggregate(groupBy=[c_custkey, n_name], auxGrouping=[c_name, c_acctbal, c_phone, c_address, c_comment], select=[c_custkey, n_name, c_name, c_acctbal, c_phone, c_address, c_comment, Partial_SUM($f7) AS sum$0])
                  +- Calc(select=[c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment, *(l_extendedprice, -(1, l_discount)) AS $f7])
                     +- HashJoin(where=[=(l_orderkey, o_orderkey)], join=[l_orderkey, l_extendedprice, l_discount, c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, o_orderkey, n_name], joinType=[InnerJoin], build=[right])
                        :- Exchange(distribution=[hash[l_orderkey]])
                        :  +- Calc(select=[l_orderkey, l_extendedprice, l_discount], where=[=(l_returnflag, 'R')])
                        :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_extendedprice, l_discount, l_returnflag];filterPredicates=[]]]], fields=[l_orderkey, l_extendedprice, l_discount, l_returnflag])
                        +- Calc(select=[c_custkey, c_name, c_address, c_phone, c_acctbal, c_comment, o_orderkey, n_name])
                           +- HashJoin(where=[=(c_nationkey, n_nationkey)], join=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, o_orderkey, n_nationkey, n_name], joinType=[InnerJoin], isBroadcast=[true], build=[right])
                              :- Exchange(distribution=[hash[o_orderkey]])
                              :  +- Calc(select=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, o_orderkey])
                              :     +- HashJoin(where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
                              :        :- Exchange(distribution=[hash[c_custkey]])
                              :        :  +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment];filterPredicates=[]]]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment])
                              :        +- Exchange(distribution=[hash[o_custkey]])
                              :           +- Calc(select=[o_orderkey, o_custkey], where=[AND(>=(o_orderdate, 1994-03-01), <(o_orderdate, 1994-06-01))])
                              :              +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_orderdate])
                              +- Exchange(distribution=[broadcast])
                                 +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=11, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch11 using 1395599672 as a seed to the RNG
select
  ps.ps_partkey,
  sum(ps.ps_supplycost * ps.ps_availqty) as `value`
from
  partsupp ps,
  supplier s,
  nation n
where
  ps.ps_suppkey = s.s_suppkey
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'JAPAN'
group by
  ps.ps_partkey having
    sum(ps.ps_supplycost * ps.ps_availqty) > (
      select
        sum(ps.ps_supplycost * ps.ps_availqty) * 0.0001000000
      from
        partsupp ps,
        supplier s,
        nation n
      where
        ps.ps_suppkey = s.s_suppkey
        and s.s_nationkey = n.n_nationkey
        and n.n_name = 'JAPAN'
    )
order by
  `value` desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], dir0=[DESC-nulls-last])
+- LogicalFilter(condition=[>($1, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*($0, 0.0001000000)])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)])
    LogicalProject($f0=[*($3, $2)])
      LogicalFilter(condition=[AND(=($1, $5), =($8, $12), =($13, 'JAPAN'))])
        LogicalJoin(condition=[true], joinType=[inner])
          LogicalJoin(condition=[true], joinType=[inner])
            LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
          LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
}))])
   +- LogicalAggregate(group=[{0}], value=[SUM($1)])
      +- LogicalProject(ps_partkey=[$0], $f1=[*($3, $2)])
         +- LogicalFilter(condition=[AND(=($1, $5), =($8, $12), =($13, 'JAPAN'))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[ps_partkey, value])
+- SortLimit(orderBy=[value DESC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[value DESC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[>(value, $f0)], join=[ps_partkey, value, $f0], joinType=[InnerJoin], build=[right], singleRowJoin=[true])
            :- HashAggregate(isMerge=[false], groupBy=[ps_partkey], select=[ps_partkey, SUM($f1) AS value])
            :  +- Exchange(distribution=[hash[ps_partkey]])
            :     +- Calc(select=[ps_partkey, *(ps_supplycost, ps_availqty) AS $f1])
            :        +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, s_suppkey], joinType=[InnerJoin], build=[right])
            :           :- Exchange(distribution=[hash[ps_suppkey]])
            :           :  +- Calc(select=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost], where=[RUNTIME_FILTER_1(ps_suppkey)])
            :           :     +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost])
            :           +- Exchange(distribution=[hash[s_suppkey]])
            :              +- Calc(select=[s_suppkey], where=[RUNTIME_FILTER_BUILDER_1(s_suppkey)])
            :                 +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
            :                    :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
            :                    +- Exchange(distribution=[broadcast])
            :                       +- Calc(select=[n_nationkey], where=[=(n_name, 'JAPAN')])
            :                          +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
            +- Exchange(distribution=[broadcast])
               +- SortAggregate(isMerge=[false], select=[SINGLE_VALUE(EXPR$0) AS $f0])
                  +- Calc(select=[*($f0, 0.0001000000) AS EXPR$0])
                     +- SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0])
                        +- Exchange(distribution=[single])
                           +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
                              +- Calc(select=[*(ps_supplycost, ps_availqty) AS $f0])
                                 +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_suppkey, ps_availqty, ps_supplycost, s_suppkey], joinType=[InnerJoin], build=[right])
                                    :- Exchange(distribution=[hash[ps_suppkey]])
                                    :  +- Calc(select=[ps_suppkey, ps_availqty, ps_supplycost], where=[RUNTIME_FILTER_0(ps_suppkey)])
                                    :     +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_suppkey, ps_availqty, ps_supplycost];filterPredicates=[]]]], fields=[ps_suppkey, ps_availqty, ps_supplycost])
                                    +- Exchange(distribution=[hash[s_suppkey]])
                                       +- Calc(select=[s_suppkey], where=[RUNTIME_FILTER_BUILDER_0(s_suppkey)])
                                          +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
                                             :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                                             +- Exchange(distribution=[broadcast])
                                                +- Calc(select=[n_nationkey], where=[=(n_name, 'JAPAN')])
                                                   +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=11, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch11 using 1395599672 as a seed to the RNG
select
  ps.ps_partkey,
  sum(ps.ps_supplycost * ps.ps_availqty) as `value`
from
  partsupp ps,
  supplier s,
  nation n
where
  ps.ps_suppkey = s.s_suppkey
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'JAPAN'
group by
  ps.ps_partkey having
    sum(ps.ps_supplycost * ps.ps_availqty) > (
      select
        sum(ps.ps_supplycost * ps.ps_availqty) * 0.0001000000
      from
        partsupp ps,
        supplier s,
        nation n
      where
        ps.ps_suppkey = s.s_suppkey
        and s.s_nationkey = n.n_nationkey
        and n.n_name = 'JAPAN'
    )
order by
  `value` desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], dir0=[DESC-nulls-last])
+- LogicalFilter(condition=[>($1, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*($0, 0.0001000000)])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)])
    LogicalProject($f0=[*($3, $2)])
      LogicalFilter(condition=[AND(=($1, $5), =($8, $12), =($13, 'JAPAN'))])
        LogicalJoin(condition=[true], joinType=[inner])
          LogicalJoin(condition=[true], joinType=[inner])
            LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
          LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
}))])
   +- LogicalAggregate(group=[{0}], value=[SUM($1)])
      +- LogicalProject(ps_partkey=[$0], $f1=[*($3, $2)])
         +- LogicalFilter(condition=[AND(=($1, $5), =($8, $12), =($13, 'JAPAN'))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[ps_partkey, value])
+- SortLimit(orderBy=[value DESC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[value DESC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[>(value, $f0)], join=[ps_partkey, value, $f0], joinType=[InnerJoin], build=[right], singleRowJoin=[true])
            :- HashAggregate(isMerge=[true], groupBy=[ps_partkey], select=[ps_partkey, Final_SUM(sum$0) AS value])
            :  +- Exchange(distribution=[hash[ps_partkey]])
            :     +- LocalHashAggregate(groupBy=[ps_partkey], select=[ps_partkey, Partial_SUM($f1) AS sum$0])
            :        +- Calc(select=[ps_partkey, *(ps_supplycost, ps_availqty) AS $f1])
            :           +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, s_suppkey], joinType=[InnerJoin], build=[right])
            :              :- Exchange(distribution=[hash[ps_suppkey]])
            :              :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost])
            :              +- Exchange(distribution=[hash[s_suppkey]])
            :                 +- Calc(select=[s_suppkey])
            :                    +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
            :                       :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
            :                       +- Exchange(distribution=[broadcast])
            :                          +- Calc(select=[n_nationkey], where=[=(n_name, 'JAPAN')])
            :                             +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
            +- Exchange(distribution=[broadcast])
               +- SortAggregate(isMerge=[false], select=[SINGLE_VALUE(EXPR$0) AS $f0])
                  +- Calc(select=[*($f0, 0.0001000000) AS EXPR$0])
                     +- SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0])
                        +- Exchange(distribution=[single])
                           +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
                              +- Calc(select=[*(ps_supplycost, ps_availqty) AS $f0])
                                 +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_suppkey, ps_availqty, ps_supplycost, s_suppkey], joinType=[InnerJoin], build=[right])
                                    :- Exchange(distribution=[hash[ps_suppkey]])
                                    :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_suppkey, ps_availqty, ps_supplycost];filterPredicates=[]]]], fields=[ps_suppkey, ps_availqty, ps_supplycost])
                                    +- Exchange(distribution=[hash[s_suppkey]])
                                       +- Calc(select=[s_suppkey])
                                          +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
                                             :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                                             +- Exchange(distribution=[broadcast])
                                                +- Calc(select=[n_nationkey], where=[=(n_name, 'JAPAN')])
                                                   +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=11, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch11 using 1395599672 as a seed to the RNG
select
  ps.ps_partkey,
  sum(ps.ps_supplycost * ps.ps_availqty) as `value`
from
  partsupp ps,
  supplier s,
  nation n
where
  ps.ps_suppkey = s.s_suppkey
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'JAPAN'
group by
  ps.ps_partkey having
    sum(ps.ps_supplycost * ps.ps_availqty) > (
      select
        sum(ps.ps_supplycost * ps.ps_availqty) * 0.0001000000
      from
        partsupp ps,
        supplier s,
        nation n
      where
        ps.ps_suppkey = s.s_suppkey
        and s.s_nationkey = n.n_nationkey
        and n.n_name = 'JAPAN'
    )
order by
  `value` desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], dir0=[DESC-nulls-last])
+- LogicalFilter(condition=[>($1, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*($0, 0.0001000000)])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)])
    LogicalProject($f0=[*($3, $2)])
      LogicalFilter(condition=[AND(=($1, $5), =($8, $12), =($13, 'JAPAN'))])
        LogicalJoin(condition=[true], joinType=[inner])
          LogicalJoin(condition=[true], joinType=[inner])
            LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
          LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
}))])
   +- LogicalAggregate(group=[{0}], value=[SUM($1)])
      +- LogicalProject(ps_partkey=[$0], $f1=[*($3, $2)])
         +- LogicalFilter(condition=[AND(=($1, $5), =($8, $12), =($13, 'JAPAN'))])
            +- LogicalJoin(condition=[true], joinType=[inner])
               :- LogicalJoin(condition=[true], joinType=[inner])
               :  :- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
               :  +- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[ps_partkey, value])
+- SortLimit(orderBy=[value DESC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[value DESC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[>(value, $f0)], join=[ps_partkey, value, $f0], joinType=[InnerJoin], build=[right], singleRowJoin=[true])
            :- HashAggregate(isMerge=[true], groupBy=[ps_partkey], select=[ps_partkey, Final_SUM(sum$0) AS value])
            :  +- Exchange(distribution=[hash[ps_partkey]])
            :     +- LocalHashAggregate(groupBy=[ps_partkey], select=[ps_partkey, Partial_SUM($f1) AS sum$0])
            :        +- Calc(select=[ps_partkey, *(ps_supplycost, ps_availqty) AS $f1])
            :           +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, s_suppkey], joinType=[InnerJoin], build=[right])
            :              :- Exchange(distribution=[hash[ps_suppkey]])
            :              :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost])
            :              +- Exchange(distribution=[hash[s_suppkey]])
            :                 +- Calc(select=[s_suppkey])
            :                    +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
            :                       :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
            :                       +- Exchange(distribution=[broadcast])
            :                          +- Calc(select=[n_nationkey], where=[=(n_name, 'JAPAN')])
            :                             +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
            +- Exchange(distribution=[broadcast])
               +- SortAggregate(isMerge=[false], select=[SINGLE_VALUE(EXPR$0) AS $f0])
                  +- Calc(select=[*($f0, 0.0001000000) AS EXPR$0])
                     +- SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0])
                        +- Exchange(distribution=[single])
                           +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
                              +- Calc(select=[*(ps_supplycost, ps_availqty) AS $f0])
                                 +- HashJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_suppkey, ps_availqty, ps_supplycost, s_suppkey], joinType=[InnerJoin], build=[right])
                                    :- Exchange(distribution=[hash[ps_suppkey]])
                                    :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_suppkey, ps_availqty, ps_supplycost];filterPredicates=[]]]], fields=[ps_suppkey, ps_availqty, ps_supplycost])
                                    +- Exchange(distribution=[hash[s_suppkey]])
                                       +- Calc(select=[s_suppkey])
                                          +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
                                             :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_nationkey])
                                             +- Exchange(distribution=[broadcast])
                                                +- Calc(select=[n_nationkey], where=[=(n_name, 'JAPAN')])
                                                   +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=12, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch12 using 1395599672 as a seed to the RNG
select
  l.l_shipmode,
  sum(case
    when o.o_orderpriority = '1-URGENT'
      or o.o_orderpriority = '2-HIGH'
      then 1
    else 0
  end) as high_line_count,
  sum(case
    when o.o_orderpriority <> '1-URGENT'
      and o.o_orderpriority <> '2-HIGH'
      then 1
    else 0
  end) as low_line_count
from
  orders o,
  lineitem l
where
  o.o_orderkey = l.l_orderkey
  and l.l_shipmode in ('TRUCK', 'REG AIR')
  and l.l_commitdate < l.l_receiptdate
  and l.l_shipdate < l.l_commitdate
  and l.l_receiptdate >= date '1994-01-01'
  and l.l_receiptdate < date '1994-01-01' + interval '1' year
group by
  l.l_shipmode
order by
  l.l_shipmode
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], high_line_count=[SUM($1)], low_line_count=[SUM($2)])
   +- LogicalProject(l_shipmode=[$23], $f1=[CASE(OR(=($5, '1-URGENT'), =($5, '2-HIGH')), 1, 0)], $f2=[CASE(AND(<>($5, '1-URGENT'), <>($5, '2-HIGH')), 1, 0)])
      +- LogicalFilter(condition=[AND(=($0, $9), OR(=($23, 'TRUCK'), =($23, 'REG AIR')), <($20, $21), <($19, $20), >=($21, 1994-01-01), <($21, +(1994-01-01, 12)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[l_shipmode ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[l_shipmode ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[l_shipmode], select=[l_shipmode, Final_SUM(sum$0) AS high_line_count, Final_SUM(sum$1) AS low_line_count])
         +- Exchange(distribution=[hash[l_shipmode]])
            +- LocalHashAggregate(groupBy=[l_shipmode], select=[l_shipmode, Partial_SUM($f1) AS sum$0, Partial_SUM($f2) AS sum$1])
               +- Calc(select=[l_shipmode, CASE(OR(=(o_orderpriority, '1-URGENT'), =(o_orderpriority, '2-HIGH')), 1, 0) AS $f1, CASE(AND(<>(o_orderpriority, '1-URGENT'), <>(o_orderpriority, '2-HIGH')), 1, 0) AS $f2])
                  +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_orderpriority, l_orderkey, l_shipmode], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderpriority];filterPredicates=[]]]], fields=[o_orderkey, o_orderpriority])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[l_orderkey, l_shipmode], where=[AND(AND(AND(AND(OR(=(l_shipmode, 'TRUCK'), =(l_shipmode, 'REG AIR')), <(l_commitdate, l_receiptdate)), <(l_shipdate, l_commitdate)), >=(l_receiptdate, 1994-01-01)), <(l_receiptdate, 1995-01-01))])
                           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode];filterPredicates=[]]]], fields=[l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=12, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch12 using 1395599672 as a seed to the RNG
select
  l.l_shipmode,
  sum(case
    when o.o_orderpriority = '1-URGENT'
      or o.o_orderpriority = '2-HIGH'
      then 1
    else 0
  end) as high_line_count,
  sum(case
    when o.o_orderpriority <> '1-URGENT'
      and o.o_orderpriority <> '2-HIGH'
      then 1
    else 0
  end) as low_line_count
from
  orders o,
  lineitem l
where
  o.o_orderkey = l.l_orderkey
  and l.l_shipmode in ('TRUCK', 'REG AIR')
  and l.l_commitdate < l.l_receiptdate
  and l.l_shipdate < l.l_commitdate
  and l.l_receiptdate >= date '1994-01-01'
  and l.l_receiptdate < date '1994-01-01' + interval '1' year
group by
  l.l_shipmode
order by
  l.l_shipmode
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], high_line_count=[SUM($1)], low_line_count=[SUM($2)])
   +- LogicalProject(l_shipmode=[$23], $f1=[CASE(OR(=($5, '1-URGENT'), =($5, '2-HIGH')), 1, 0)], $f2=[CASE(AND(<>($5, '1-URGENT'), <>($5, '2-HIGH')), 1, 0)])
      +- LogicalFilter(condition=[AND(=($0, $9), OR(=($23, 'TRUCK'), =($23, 'REG AIR')), <($20, $21), <($19, $20), >=($21, 1994-01-01), <($21, +(1994-01-01, 12)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[l_shipmode ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[l_shipmode ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[l_shipmode], select=[l_shipmode, Final_SUM(sum$0) AS high_line_count, Final_SUM(sum$1) AS low_line_count])
         +- Exchange(distribution=[hash[l_shipmode]])
            +- LocalHashAggregate(groupBy=[l_shipmode], select=[l_shipmode, Partial_SUM($f1) AS sum$0, Partial_SUM($f2) AS sum$1])
               +- Calc(select=[l_shipmode, CASE(OR(=(o_orderpriority, '1-URGENT'), =(o_orderpriority, '2-HIGH')), 1, 0) AS $f1, CASE(AND(<>(o_orderpriority, '1-URGENT'), <>(o_orderpriority, '2-HIGH')), 1, 0) AS $f2])
                  +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_orderpriority, l_orderkey, l_shipmode], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderpriority];filterPredicates=[]]]], fields=[o_orderkey, o_orderpriority])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[l_orderkey, l_shipmode], where=[AND(OR(=(l_shipmode, 'TRUCK'), =(l_shipmode, 'REG AIR')), <(l_commitdate, l_receiptdate), <(l_shipdate, l_commitdate), >=(l_receiptdate, 1994-01-01), <(l_receiptdate, 1995-01-01))])
                           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode];filterPredicates=[]]]], fields=[l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=12, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch12 using 1395599672 as a seed to the RNG
select
  l.l_shipmode,
  sum(case
    when o.o_orderpriority = '1-URGENT'
      or o.o_orderpriority = '2-HIGH'
      then 1
    else 0
  end) as high_line_count,
  sum(case
    when o.o_orderpriority <> '1-URGENT'
      and o.o_orderpriority <> '2-HIGH'
      then 1
    else 0
  end) as low_line_count
from
  orders o,
  lineitem l
where
  o.o_orderkey = l.l_orderkey
  and l.l_shipmode in ('TRUCK', 'REG AIR')
  and l.l_commitdate < l.l_receiptdate
  and l.l_shipdate < l.l_commitdate
  and l.l_receiptdate >= date '1994-01-01'
  and l.l_receiptdate < date '1994-01-01' + interval '1' year
group by
  l.l_shipmode
order by
  l.l_shipmode
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], high_line_count=[SUM($1)], low_line_count=[SUM($2)])
   +- LogicalProject(l_shipmode=[$23], $f1=[CASE(OR(=($5, '1-URGENT'), =($5, '2-HIGH')), 1, 0)], $f2=[CASE(AND(<>($5, '1-URGENT'), <>($5, '2-HIGH')), 1, 0)])
      +- LogicalFilter(condition=[AND(=($0, $9), OR(=($23, 'TRUCK'), =($23, 'REG AIR')), <($20, $21), <($19, $20), >=($21, 1994-01-01), <($21, +(1994-01-01, 12)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[l_shipmode ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[l_shipmode ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[l_shipmode], select=[l_shipmode, Final_SUM(sum$0) AS high_line_count, Final_SUM(sum$1) AS low_line_count])
         +- Exchange(distribution=[hash[l_shipmode]])
            +- LocalHashAggregate(groupBy=[l_shipmode], select=[l_shipmode, Partial_SUM($f1) AS sum$0, Partial_SUM($f2) AS sum$1])
               +- Calc(select=[l_shipmode, CASE(OR(=(o_orderpriority, '1-URGENT'), =(o_orderpriority, '2-HIGH')), 1, 0) AS $f1, CASE(AND(<>(o_orderpriority, '1-URGENT'), <>(o_orderpriority, '2-HIGH')), 1, 0) AS $f2])
                  +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_orderpriority, l_orderkey, l_shipmode], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderpriority];filterPredicates=[]]]], fields=[o_orderkey, o_orderpriority])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[l_orderkey, l_shipmode], where=[AND(OR(=(l_shipmode, 'TRUCK'), =(l_shipmode, 'REG AIR')), <(l_commitdate, l_receiptdate), <(l_shipdate, l_commitdate), >=(l_receiptdate, 1994-01-01), <(l_receiptdate, 1995-01-01))])
                           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode];filterPredicates=[]]]], fields=[l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=13, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch13 using 1395599672 as a seed to the RNG
select
  c_count,
  count(*) as custdist
from
  (
    select
      c.c_custkey,
      count(o.o_orderkey)
    from
      customer c
      left outer join orders o
        on c.c_custkey = o.o_custkey
        and o.o_comment not like '%special%requests%'
    group by
      c.c_custkey
  ) as orders (c_custkey, c_count)
group by
  c_count
order by
  custdist desc,
  c_count desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$0], dir0=[DESC-nulls-last], dir1=[DESC-nulls-last])
+- LogicalAggregate(group=[{0}], custdist=[COUNT()])
   +- LogicalProject(c_count=[$1])
      +- LogicalAggregate(group=[{0}], EXPR$1=[COUNT($1)])
         +- LogicalProject(c_custkey=[$0], o_orderkey=[$8])
            +- LogicalJoin(condition=[AND(=($0, $9), NOT(LIKE($16, '%special%requests%')))], joinType=[left])
               :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[custdist DESC, c_count DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[custdist DESC, c_count DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[c_count], select=[c_count, Final_COUNT(count$0) AS custdist])
         +- Exchange(distribution=[hash[c_count]])
            +- LocalHashAggregate(groupBy=[c_count], select=[c_count, Partial_COUNT(*) AS count$0])
               +- Calc(select=[EXPR$1 AS c_count])
                  +- HashAggregate(isMerge=[false], groupBy=[c_custkey], select=[c_custkey, COUNT(o_orderkey) AS EXPR$1])
                     +- Calc(select=[c_custkey, o_orderkey])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey], joinType=[RightOuterJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- Calc(select=[o_orderkey, o_custkey], where=[NOT(LIKE(o_comment, '%special%requests%'))])
                           :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_comment];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_comment])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey];filterPredicates=[]]]], fields=[c_custkey])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=13, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch13 using 1395599672 as a seed to the RNG
select
  c_count,
  count(*) as custdist
from
  (
    select
      c.c_custkey,
      count(o.o_orderkey)
    from
      customer c
      left outer join orders o
        on c.c_custkey = o.o_custkey
        and o.o_comment not like '%special%requests%'
    group by
      c.c_custkey
  ) as orders (c_custkey, c_count)
group by
  c_count
order by
  custdist desc,
  c_count desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$0], dir0=[DESC-nulls-last], dir1=[DESC-nulls-last])
+- LogicalAggregate(group=[{0}], custdist=[COUNT()])
   +- LogicalProject(c_count=[$1])
      +- LogicalAggregate(group=[{0}], EXPR$1=[COUNT($1)])
         +- LogicalProject(c_custkey=[$0], o_orderkey=[$8])
            +- LogicalJoin(condition=[AND(=($0, $9), NOT(LIKE($16, '%special%requests%')))], joinType=[left])
               :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[custdist DESC, c_count DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[custdist DESC, c_count DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[c_count], select=[c_count, Final_COUNT(count$0) AS custdist])
         +- Exchange(distribution=[hash[c_count]])
            +- LocalHashAggregate(groupBy=[c_count], select=[c_count, Partial_COUNT(*) AS count$0])
               +- Calc(select=[EXPR$1 AS c_count])
                  +- HashAggregate(isMerge=[false], groupBy=[c_custkey], select=[c_custkey, COUNT(o_orderkey) AS EXPR$1])
                     +- Calc(select=[c_custkey, o_orderkey])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey], joinType=[RightOuterJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- Calc(select=[o_orderkey, o_custkey], where=[NOT(LIKE(o_comment, '%special%requests%'))])
                           :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_comment];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_comment])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey];filterPredicates=[]]]], fields=[c_custkey])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=13, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch13 using 1395599672 as a seed to the RNG
select
  c_count,
  count(*) as custdist
from
  (
    select
      c.c_custkey,
      count(o.o_orderkey)
    from
      customer c
      left outer join orders o
        on c.c_custkey = o.o_custkey
        and o.o_comment not like '%special%requests%'
    group by
      c.c_custkey
  ) as orders (c_custkey, c_count)
group by
  c_count
order by
  custdist desc,
  c_count desc
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$0], dir0=[DESC-nulls-last], dir1=[DESC-nulls-last])
+- LogicalAggregate(group=[{0}], custdist=[COUNT()])
   +- LogicalProject(c_count=[$1])
      +- LogicalAggregate(group=[{0}], EXPR$1=[COUNT($1)])
         +- LogicalProject(c_custkey=[$0], o_orderkey=[$8])
            +- LogicalJoin(condition=[AND(=($0, $9), NOT(LIKE($16, '%special%requests%')))], joinType=[left])
               :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
               +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[custdist DESC, c_count DESC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[custdist DESC, c_count DESC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[c_count], select=[c_count, Final_COUNT(count$0) AS custdist])
         +- Exchange(distribution=[hash[c_count]])
            +- LocalHashAggregate(groupBy=[c_count], select=[c_count, Partial_COUNT(*) AS count$0])
               +- Calc(select=[EXPR$1 AS c_count])
                  +- HashAggregate(isMerge=[false], groupBy=[c_custkey], select=[c_custkey, COUNT(o_orderkey) AS EXPR$1])
                     +- Calc(select=[c_custkey, o_orderkey])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, c_custkey], joinType=[RightOuterJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- Calc(select=[o_orderkey, o_custkey], where=[NOT(LIKE(o_comment, '%special%requests%'))])
                           :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_comment];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_comment])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey];filterPredicates=[]]]], fields=[c_custkey])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=14, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch14 using 1395599672 as a seed to the RNG
select
  100.00 * sum(case
    when p.p_type like 'PROMO%'
      then l.l_extendedprice * (1 - l.l_discount)
    else 0
  end) / sum(l.l_extendedprice * (1 - l.l_discount)) as promo_revenue
from
  lineitem l,
  part p
where
  l.l_partkey = p.p_partkey
  and l.l_shipdate >= date '1994-08-01'
  and l.l_shipdate < date '1994-08-01' + interval '1' month
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(promo_revenue=[/(*(100.00, $0), $1)])
+- LogicalAggregate(group=[{}], agg#0=[SUM($0)], agg#1=[SUM($1)])
   +- LogicalProject($f0=[CASE(LIKE($20, 'PROMO%'), *($5, -(1, $6)), 0)], $f1=[*($5, -(1, $6))])
      +- LogicalFilter(condition=[AND(=($1, $16), >=($10, 1994-08-01), <($10, +(1994-08-01, 1)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[/(*(100.00, $f0), $f1) AS promo_revenue])
+- HashAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0, Final_SUM(sum$1) AS $f1])
   +- Exchange(distribution=[single])
      +- LocalHashAggregate(select=[Partial_SUM($f0) AS sum$0, Partial_SUM($f1) AS sum$1])
         +- Calc(select=[CASE(LIKE(p_type, 'PROMO%'), *(l_extendedprice, -(1, l_discount)), 0) AS $f0, *(l_extendedprice, -(1, l_discount)) AS $f1])
            +- HashJoin(where=[=(l_partkey, p_partkey)], join=[p_partkey, p_type, l_partkey, l_extendedprice, l_discount], joinType=[InnerJoin], build=[right])
               :- Exchange(distribution=[hash[p_partkey]])
               :  +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_type];filterPredicates=[]]]], fields=[p_partkey, p_type])
               +- Exchange(distribution=[hash[l_partkey]])
                  +- Calc(select=[l_partkey, l_extendedprice, l_discount], where=[AND(>=(l_shipdate, 1994-08-01), <(l_shipdate, 1994-09-01))])
                     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_partkey, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=14, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch14 using 1395599672 as a seed to the RNG
select
  100.00 * sum(case
    when p.p_type like 'PROMO%'
      then l.l_extendedprice * (1 - l.l_discount)
    else 0
  end) / sum(l.l_extendedprice * (1 - l.l_discount)) as promo_revenue
from
  lineitem l,
  part p
where
  l.l_partkey = p.p_partkey
  and l.l_shipdate >= date '1994-08-01'
  and l.l_shipdate < date '1994-08-01' + interval '1' month
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(promo_revenue=[/(*(100.00, $0), $1)])
+- LogicalAggregate(group=[{}], agg#0=[SUM($0)], agg#1=[SUM($1)])
   +- LogicalProject($f0=[CASE(LIKE($20, 'PROMO%'), *($5, -(1, $6)), 0)], $f1=[*($5, -(1, $6))])
      +- LogicalFilter(condition=[AND(=($1, $16), >=($10, 1994-08-01), <($10, +(1994-08-01, 1)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[/(*(100.00, $f0), $f1) AS promo_revenue])
+- HashAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0, Final_SUM(sum$1) AS $f1])
   +- Exchange(distribution=[single])
      +- LocalHashAggregate(select=[Partial_SUM($f0) AS sum$0, Partial_SUM($f1) AS sum$1])
         +- Calc(select=[CASE(LIKE(p_type, 'PROMO%'), *(l_extendedprice, -(1, l_discount)), 0) AS $f0, *(l_extendedprice, -(1, l_discount)) AS $f1])
            +- HashJoin(where=[=(l_partkey, p_partkey)], join=[l_partkey, l_extendedprice, l_discount, p_partkey, p_type], joinType=[InnerJoin], build=[right])
               :- Exchange(distribution=[hash[l_partkey]])
               :  +- Calc(select=[l_partkey, l_extendedprice, l_discount], where=[AND(>=(l_shipdate, 1994-08-01), <(l_shipdate, 1994-09-01))])
               :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_partkey, l_extendedprice, l_discount, l_shipdate])
               +- Exchange(distribution=[hash[p_partkey]])
                  +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_type];filterPredicates=[]]]], fields=[p_partkey, p_type])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=14, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch14 using 1395599672 as a seed to the RNG
select
  100.00 * sum(case
    when p.p_type like 'PROMO%'
      then l.l_extendedprice * (1 - l.l_discount)
    else 0
  end) / sum(l.l_extendedprice * (1 - l.l_discount)) as promo_revenue
from
  lineitem l,
  part p
where
  l.l_partkey = p.p_partkey
  and l.l_shipdate >= date '1994-08-01'
  and l.l_shipdate < date '1994-08-01' + interval '1' month
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(promo_revenue=[/(*(100.00, $0), $1)])
+- LogicalAggregate(group=[{}], agg#0=[SUM($0)], agg#1=[SUM($1)])
   +- LogicalProject($f0=[CASE(LIKE($20, 'PROMO%'), *($5, -(1, $6)), 0)], $f1=[*($5, -(1, $6))])
      +- LogicalFilter(condition=[AND(=($1, $16), >=($10, 1994-08-01), <($10, +(1994-08-01, 1)))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[/(*(100.00, $f0), $f1) AS promo_revenue])
+- HashAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0, Final_SUM(sum$1) AS $f1])
   +- Exchange(distribution=[single])
      +- LocalHashAggregate(select=[Partial_SUM($f0) AS sum$0, Partial_SUM($f1) AS sum$1])
         +- Calc(select=[CASE(LIKE(p_type, 'PROMO%'), *(l_extendedprice, -(1, l_discount)), 0) AS $f0, *(l_extendedprice, -(1, l_discount)) AS $f1])
            +- HashJoin(where=[=(l_partkey, p_partkey)], join=[p_partkey, p_type, l_partkey, l_extendedprice, l_discount], joinType=[InnerJoin], build=[right])
               :- Exchange(distribution=[hash[p_partkey]])
               :  +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_type];filterPredicates=[]]]], fields=[p_partkey, p_type])
               +- Exchange(distribution=[hash[l_partkey]])
                  +- Calc(select=[l_partkey, l_extendedprice, l_discount], where=[AND(>=(l_shipdate, 1994-08-01), <(l_shipdate, 1994-09-01))])
                     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_partkey, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=15_1, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch15 using 1395599672 as a seed to the RNG

select
  s.s_suppkey,
  s.s_name,
  s.s_address,
  s.s_phone,
  r.total_revenue
from
  supplier s,
  (
  select
      l_suppkey as supplier_no,
      sum(l_extendedprice * (1 - l_discount)) as total_revenue
    from
      lineitem
    where
      l_shipdate >= date '1993-05-01'
      and l_shipdate < date '1993-05-01' + interval '3' month
    group by
      l_suppkey
  ) as r
where
  s.s_suppkey = r.supplier_no
  and r.total_revenue = (
    select
      max(total_revenue)
    from
    (
      select
          l_suppkey as supplier_no,
          sum(l_extendedprice * (1 - l_discount)) as total_revenue
        from
          lineitem
        where
          l_shipdate >= date '1993-05-01'
          and l_shipdate < date '1993-05-01' + interval '3' month
        group by
          l_suppkey
    ) as revenue0
  )
order by
  s.s_suppkey

]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(s_suppkey=[$0], s_name=[$1], s_address=[$2], s_phone=[$4], total_revenue=[$8])
   +- LogicalFilter(condition=[AND(=($0, $7), =($8, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[MAX($0)])
  LogicalProject(total_revenue=[$1])
    LogicalAggregate(group=[{0}], total_revenue=[SUM($1)])
      LogicalProject(supplier_no=[$2], $f1=[*($5, -(1, $6))])
        LogicalFilter(condition=[AND(>=($10, 1993-05-01), <($10, +(1993-05-01, 3)))])
          LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         +- LogicalAggregate(group=[{0}], total_revenue=[SUM($1)])
            +- LogicalProject(supplier_no=[$2], $f1=[*($5, -(1, $6))])
               +- LogicalFilter(condition=[AND(>=($10, 1993-05-01), <($10, +(1993-05-01, 3)))])
                  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_suppkey, s_name, s_address, s_phone, total_revenue])
+- SortLimit(orderBy=[s_suppkey ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_suppkey ASC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[=(s_suppkey, supplier_no)], join=[s_suppkey, s_name, s_address, s_phone, supplier_no, total_revenue], joinType=[InnerJoin], build=[right])
            :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_phone];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_phone])
            +- Exchange(distribution=[broadcast])
               +- Rank(rankFunction=[RANK], partitionBy=[], orderBy=[total_revenue DESC], rankRange=[rankStart=1, rankEnd=1], global=[true], select=[supplier_no, total_revenue])
                  +- Sort(orderBy=[total_revenue DESC])
                     +- Exchange(distribution=[single])
                        +- Rank(rankFunction=[RANK], partitionBy=[], orderBy=[total_revenue DESC], rankRange=[rankStart=1, rankEnd=1], global=[false], select=[supplier_no, total_revenue])
                           +- Sort(orderBy=[total_revenue DESC])
                              +- HashAggregate(isMerge=[false], groupBy=[supplier_no], select=[supplier_no, SUM($f1) AS total_revenue])
                                 +- Exchange(distribution=[hash[supplier_no]])
                                    +- Calc(select=[l_suppkey AS supplier_no, *(l_extendedprice, -(1, l_discount)) AS $f1], where=[AND(>=(l_shipdate, 1993-05-01), <(l_shipdate, 1993-08-01))])
                                       +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_suppkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_suppkey, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=15_1, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch15 using 1395599672 as a seed to the RNG

select
  s.s_suppkey,
  s.s_name,
  s.s_address,
  s.s_phone,
  r.total_revenue
from
  supplier s,
  (
  select
      l_suppkey as supplier_no,
      sum(l_extendedprice * (1 - l_discount)) as total_revenue
    from
      lineitem
    where
      l_shipdate >= date '1993-05-01'
      and l_shipdate < date '1993-05-01' + interval '3' month
    group by
      l_suppkey
  ) as r
where
  s.s_suppkey = r.supplier_no
  and r.total_revenue = (
    select
      max(total_revenue)
    from
    (
      select
          l_suppkey as supplier_no,
          sum(l_extendedprice * (1 - l_discount)) as total_revenue
        from
          lineitem
        where
          l_shipdate >= date '1993-05-01'
          and l_shipdate < date '1993-05-01' + interval '3' month
        group by
          l_suppkey
    ) as revenue0
  )
order by
  s.s_suppkey

]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(s_suppkey=[$0], s_name=[$1], s_address=[$2], s_phone=[$4], total_revenue=[$8])
   +- LogicalFilter(condition=[AND(=($0, $7), =($8, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[MAX($0)])
  LogicalProject(total_revenue=[$1])
    LogicalAggregate(group=[{0}], total_revenue=[SUM($1)])
      LogicalProject(supplier_no=[$2], $f1=[*($5, -(1, $6))])
        LogicalFilter(condition=[AND(>=($10, 1993-05-01), <($10, +(1993-05-01, 3)))])
          LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         +- LogicalAggregate(group=[{0}], total_revenue=[SUM($1)])
            +- LogicalProject(supplier_no=[$2], $f1=[*($5, -(1, $6))])
               +- LogicalFilter(condition=[AND(>=($10, 1993-05-01), <($10, +(1993-05-01, 3)))])
                  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_suppkey, s_name, s_address, s_phone, total_revenue])
+- SortLimit(orderBy=[s_suppkey ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_suppkey ASC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[=(s_suppkey, supplier_no)], join=[s_suppkey, s_name, s_address, s_phone, supplier_no, total_revenue], joinType=[InnerJoin], build=[right])
            :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_phone];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_phone])
            +- Exchange(distribution=[broadcast])
               +- Rank(rankFunction=[RANK], partitionBy=[], orderBy=[total_revenue DESC], rankRange=[rankStart=1, rankEnd=1], global=[true], select=[supplier_no, total_revenue])
                  +- Sort(orderBy=[total_revenue DESC])
                     +- Exchange(distribution=[single])
                        +- Rank(rankFunction=[RANK], partitionBy=[], orderBy=[total_revenue DESC], rankRange=[rankStart=1, rankEnd=1], global=[false], select=[supplier_no, total_revenue])
                           +- Sort(orderBy=[total_revenue DESC])
                              +- HashAggregate(isMerge=[true], groupBy=[supplier_no], select=[supplier_no, Final_SUM(sum$0) AS total_revenue])
                                 +- Exchange(distribution=[hash[supplier_no]])
                                    +- LocalHashAggregate(groupBy=[supplier_no], select=[supplier_no, Partial_SUM($f1) AS sum$0])
                                       +- Calc(select=[l_suppkey AS supplier_no, *(l_extendedprice, -(1, l_discount)) AS $f1], where=[AND(>=(l_shipdate, 1993-05-01), <(l_shipdate, 1993-08-01))])
                                          +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_suppkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_suppkey, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=15_1, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch15 using 1395599672 as a seed to the RNG

select
  s.s_suppkey,
  s.s_name,
  s.s_address,
  s.s_phone,
  r.total_revenue
from
  supplier s,
  (
  select
      l_suppkey as supplier_no,
      sum(l_extendedprice * (1 - l_discount)) as total_revenue
    from
      lineitem
    where
      l_shipdate >= date '1993-05-01'
      and l_shipdate < date '1993-05-01' + interval '3' month
    group by
      l_suppkey
  ) as r
where
  s.s_suppkey = r.supplier_no
  and r.total_revenue = (
    select
      max(total_revenue)
    from
    (
      select
          l_suppkey as supplier_no,
          sum(l_extendedprice * (1 - l_discount)) as total_revenue
        from
          lineitem
        where
          l_shipdate >= date '1993-05-01'
          and l_shipdate < date '1993-05-01' + interval '3' month
        group by
          l_suppkey
    ) as revenue0
  )
order by
  s.s_suppkey

]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(s_suppkey=[$0], s_name=[$1], s_address=[$2], s_phone=[$4], total_revenue=[$8])
   +- LogicalFilter(condition=[AND(=($0, $7), =($8, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[MAX($0)])
  LogicalProject(total_revenue=[$1])
    LogicalAggregate(group=[{0}], total_revenue=[SUM($1)])
      LogicalProject(supplier_no=[$2], $f1=[*($5, -(1, $6))])
        LogicalFilter(condition=[AND(>=($10, 1993-05-01), <($10, +(1993-05-01, 3)))])
          LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         +- LogicalAggregate(group=[{0}], total_revenue=[SUM($1)])
            +- LogicalProject(supplier_no=[$2], $f1=[*($5, -(1, $6))])
               +- LogicalFilter(condition=[AND(>=($10, 1993-05-01), <($10, +(1993-05-01, 3)))])
                  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_suppkey, s_name, s_address, s_phone, total_revenue])
+- SortLimit(orderBy=[s_suppkey ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_suppkey ASC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[=(s_suppkey, supplier_no)], join=[s_suppkey, s_name, s_address, s_phone, supplier_no, total_revenue], joinType=[InnerJoin], build=[right])
            :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_phone];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_phone])
            +- Exchange(distribution=[broadcast])
               +- Rank(rankFunction=[RANK], partitionBy=[], orderBy=[total_revenue DESC], rankRange=[rankStart=1, rankEnd=1], global=[true], select=[supplier_no, total_revenue])
                  +- Sort(orderBy=[total_revenue DESC])
                     +- Exchange(distribution=[single])
                        +- Rank(rankFunction=[RANK], partitionBy=[], orderBy=[total_revenue DESC], rankRange=[rankStart=1, rankEnd=1], global=[false], select=[supplier_no, total_revenue])
                           +- Sort(orderBy=[total_revenue DESC])
                              +- HashAggregate(isMerge=[true], groupBy=[supplier_no], select=[supplier_no, Final_SUM(sum$0) AS total_revenue])
                                 +- Exchange(distribution=[hash[supplier_no]])
                                    +- LocalHashAggregate(groupBy=[supplier_no], select=[supplier_no, Partial_SUM($f1) AS sum$0])
                                       +- Calc(select=[l_suppkey AS supplier_no, *(l_extendedprice, -(1, l_discount)) AS $f1], where=[AND(>=(l_shipdate, 1993-05-01), <(l_shipdate, 1993-08-01))])
                                          +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_suppkey, l_extendedprice, l_discount, l_shipdate];filterPredicates=[]]]], fields=[l_suppkey, l_extendedprice, l_discount, l_shipdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=16, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch16 using 1395599672 as a seed to the RNG
select
  p.p_brand,
  p.p_type,
  p.p_size,
  count(distinct ps.ps_suppkey) as supplier_cnt
from
  partsupp ps,
  part p
where
  p.p_partkey = ps.ps_partkey
  and p.p_brand <> 'Brand#21'
  and p.p_type not like 'MEDIUM PLATED%'
  and p.p_size in (38, 2, 8, 31, 44, 5, 14, 24)
  and ps.ps_suppkey not in (
    select
      s.s_suppkey
    from
      supplier s
    where
      s.s_comment like '%Customer%Complaints%'
  )
group by
  p.p_brand,
  p.p_type,
  p.p_size
order by
  supplier_cnt desc,
  p.p_brand,
  p.p_type,
  p.p_size
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$3], sort1=[$0], sort2=[$1], sort3=[$2], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first], dir3=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1, 2}], supplier_cnt=[COUNT(DISTINCT $3)])
   +- LogicalProject(p_brand=[$8], p_type=[$9], p_size=[$10], ps_suppkey=[$1])
      +- LogicalFilter(condition=[AND(=($5, $0), <>($8, 'Brand#21'), NOT(LIKE($9, 'MEDIUM PLATED%')), OR(=($10, 38), =($10, 2), =($10, 8), =($10, 31), =($10, 44), =($10, 5), =($10, 14), =($10, 24)), NOT(IN($1, {
LogicalProject(s_suppkey=[$0])
  LogicalFilter(condition=[LIKE($6, '%Customer%Complaints%')])
    LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
})))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[supplier_cnt DESC, p_brand ASC, p_type ASC, p_size ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[supplier_cnt DESC, p_brand ASC, p_type ASC, p_size ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[p_brand, p_type, p_size], select=[p_brand, p_type, p_size, Final_COUNT(count$0) AS supplier_cnt])
         +- Exchange(distribution=[hash[p_brand, p_type, p_size]])
            +- LocalHashAggregate(groupBy=[p_brand, p_type, p_size], select=[p_brand, p_type, p_size, Partial_COUNT(ps_suppkey) AS count$0])
               +- HashAggregate(isMerge=[false], groupBy=[ps_suppkey, p_brand, p_type, p_size], select=[ps_suppkey, p_brand, p_type, p_size])
                  +- HashSemiJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_suppkey, p_brand, p_type, p_size], joinType=[LeftAntiJoin], build=[right])
                     :- Exchange(distribution=[hash[ps_suppkey]])
                     :  +- Calc(select=[ps_suppkey, p_brand, p_type, p_size])
                     :     +- HashJoin(where=[=(p_partkey, ps_partkey)], join=[ps_partkey, ps_suppkey, p_partkey, p_brand, p_type, p_size], joinType=[InnerJoin], build=[right])
                     :        :- Exchange(distribution=[hash[ps_partkey]])
                     :        :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey])
                     :        +- Exchange(distribution=[hash[p_partkey]])
                     :           +- Calc(select=[p_partkey, p_brand, p_type, p_size], where=[AND(AND(<>(p_brand, 'Brand#21'), IN(p_size, 38, 2, 8, 31, 44, 5, 14, 24)), NOT(LIKE(p_type, 'MEDIUM PLATED%')))])
                     :              +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_type, p_size];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_type, p_size])
                     +- Exchange(distribution=[hash[s_suppkey]])
                        +- Calc(select=[s_suppkey], where=[LIKE(s_comment, '%Customer%Complaints%')])
                           +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_comment];filterPredicates=[]]]], fields=[s_suppkey, s_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=16, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch16 using 1395599672 as a seed to the RNG
select
  p.p_brand,
  p.p_type,
  p.p_size,
  count(distinct ps.ps_suppkey) as supplier_cnt
from
  partsupp ps,
  part p
where
  p.p_partkey = ps.ps_partkey
  and p.p_brand <> 'Brand#21'
  and p.p_type not like 'MEDIUM PLATED%'
  and p.p_size in (38, 2, 8, 31, 44, 5, 14, 24)
  and ps.ps_suppkey not in (
    select
      s.s_suppkey
    from
      supplier s
    where
      s.s_comment like '%Customer%Complaints%'
  )
group by
  p.p_brand,
  p.p_type,
  p.p_size
order by
  supplier_cnt desc,
  p.p_brand,
  p.p_type,
  p.p_size
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$3], sort1=[$0], sort2=[$1], sort3=[$2], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first], dir3=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1, 2}], supplier_cnt=[COUNT(DISTINCT $3)])
   +- LogicalProject(p_brand=[$8], p_type=[$9], p_size=[$10], ps_suppkey=[$1])
      +- LogicalFilter(condition=[AND(=($5, $0), <>($8, 'Brand#21'), NOT(LIKE($9, 'MEDIUM PLATED%')), OR(=($10, 38), =($10, 2), =($10, 8), =($10, 31), =($10, 44), =($10, 5), =($10, 14), =($10, 24)), NOT(IN($1, {
LogicalProject(s_suppkey=[$0])
  LogicalFilter(condition=[LIKE($6, '%Customer%Complaints%')])
    LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
})))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[supplier_cnt DESC, p_brand ASC, p_type ASC, p_size ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[supplier_cnt DESC, p_brand ASC, p_type ASC, p_size ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[p_brand, p_type, p_size], select=[p_brand, p_type, p_size, Final_COUNT(count$0) AS supplier_cnt])
         +- Exchange(distribution=[hash[p_brand, p_type, p_size]])
            +- LocalHashAggregate(groupBy=[p_brand, p_type, p_size], select=[p_brand, p_type, p_size, Partial_COUNT(ps_suppkey) AS count$0])
               +- HashAggregate(isMerge=[true], groupBy=[p_brand, p_type, p_size, ps_suppkey], select=[p_brand, p_type, p_size, ps_suppkey])
                  +- Exchange(distribution=[hash[p_brand, p_type, p_size, ps_suppkey]])
                     +- LocalHashAggregate(groupBy=[p_brand, p_type, p_size, ps_suppkey], select=[p_brand, p_type, p_size, ps_suppkey])
                        +- Calc(select=[p_brand, p_type, p_size, ps_suppkey])
                           +- HashJoin(where=[=(p_partkey, ps_partkey)], join=[ps_partkey, ps_suppkey, p_partkey, p_brand, p_type, p_size], joinType=[InnerJoin], build=[right])
                              :- Exchange(distribution=[hash[ps_partkey]])
                              :  +- HashSemiJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_partkey, ps_suppkey], joinType=[LeftAntiJoin], build=[right])
                              :     :- Exchange(distribution=[hash[ps_suppkey]])
                              :     :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey])
                              :     +- Exchange(distribution=[hash[s_suppkey]])
                              :        +- Calc(select=[s_suppkey], where=[LIKE(s_comment, '%Customer%Complaints%')])
                              :           +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_comment];filterPredicates=[]]]], fields=[s_suppkey, s_comment])
                              +- Exchange(distribution=[hash[p_partkey]])
                                 +- Calc(select=[p_partkey, p_brand, p_type, p_size], where=[AND(<>(p_brand, 'Brand#21'), IN(p_size, 38, 2, 8, 31, 44, 5, 14, 24), NOT(LIKE(p_type, 'MEDIUM PLATED%')))])
                                    +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_type, p_size];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_type, p_size])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=16, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch16 using 1395599672 as a seed to the RNG
select
  p.p_brand,
  p.p_type,
  p.p_size,
  count(distinct ps.ps_suppkey) as supplier_cnt
from
  partsupp ps,
  part p
where
  p.p_partkey = ps.ps_partkey
  and p.p_brand <> 'Brand#21'
  and p.p_type not like 'MEDIUM PLATED%'
  and p.p_size in (38, 2, 8, 31, 44, 5, 14, 24)
  and ps.ps_suppkey not in (
    select
      s.s_suppkey
    from
      supplier s
    where
      s.s_comment like '%Customer%Complaints%'
  )
group by
  p.p_brand,
  p.p_type,
  p.p_size
order by
  supplier_cnt desc,
  p.p_brand,
  p.p_type,
  p.p_size
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$3], sort1=[$0], sort2=[$1], sort3=[$2], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first], dir3=[ASC-nulls-first])
+- LogicalAggregate(group=[{0, 1, 2}], supplier_cnt=[COUNT(DISTINCT $3)])
   +- LogicalProject(p_brand=[$8], p_type=[$9], p_size=[$10], ps_suppkey=[$1])
      +- LogicalFilter(condition=[AND(=($5, $0), <>($8, 'Brand#21'), NOT(LIKE($9, 'MEDIUM PLATED%')), OR(=($10, 38), =($10, 2), =($10, 8), =($10, 31), =($10, 44), =($10, 5), =($10, 14), =($10, 24)), NOT(IN($1, {
LogicalProject(s_suppkey=[$0])
  LogicalFilter(condition=[LIKE($6, '%Customer%Complaints%')])
    LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
})))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[supplier_cnt DESC, p_brand ASC, p_type ASC, p_size ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[supplier_cnt DESC, p_brand ASC, p_type ASC, p_size ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[p_brand, p_type, p_size], select=[p_brand, p_type, p_size, Final_COUNT(count$0) AS supplier_cnt])
         +- Exchange(distribution=[hash[p_brand, p_type, p_size]])
            +- LocalHashAggregate(groupBy=[p_brand, p_type, p_size], select=[p_brand, p_type, p_size, Partial_COUNT(ps_suppkey) AS count$0])
               +- HashAggregate(isMerge=[true], groupBy=[p_brand, p_type, p_size, ps_suppkey], select=[p_brand, p_type, p_size, ps_suppkey])
                  +- Exchange(distribution=[hash[p_brand, p_type, p_size, ps_suppkey]])
                     +- LocalHashAggregate(groupBy=[p_brand, p_type, p_size, ps_suppkey], select=[p_brand, p_type, p_size, ps_suppkey])
                        +- Calc(select=[p_brand, p_type, p_size, ps_suppkey])
                           +- HashJoin(where=[=(p_partkey, ps_partkey)], join=[ps_partkey, ps_suppkey, p_partkey, p_brand, p_type, p_size], joinType=[InnerJoin], build=[right])
                              :- Exchange(distribution=[hash[ps_partkey]])
                              :  +- HashSemiJoin(where=[=(ps_suppkey, s_suppkey)], join=[ps_partkey, ps_suppkey], joinType=[LeftAntiJoin], build=[right])
                              :     :- Exchange(distribution=[hash[ps_suppkey]])
                              :     :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey])
                              :     +- Exchange(distribution=[hash[s_suppkey]])
                              :        +- Calc(select=[s_suppkey], where=[LIKE(s_comment, '%Customer%Complaints%')])
                              :           +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_comment];filterPredicates=[]]]], fields=[s_suppkey, s_comment])
                              +- Exchange(distribution=[hash[p_partkey]])
                                 +- Calc(select=[p_partkey, p_brand, p_type, p_size], where=[AND(<>(p_brand, 'Brand#21'), IN(p_size, 38, 2, 8, 31, 44, 5, 14, 24), NOT(LIKE(p_type, 'MEDIUM PLATED%')))])
                                    +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_type, p_size];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_type, p_size])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=17, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch17 using 1395599672 as a seed to the RNG
select
  sum(l.l_extendedprice) / 7.0 as avg_yearly
from
  lineitem l,
  part p
where
  p.p_partkey = l.l_partkey
  and p.p_brand = 'Brand#13'
  and p.p_container = 'JUMBO CAN'
  and l.l_quantity < (
    select
      0.2 * avg(l2.l_quantity)
    from
      lineitem l2
    where
      l2.l_partkey = p.p_partkey
  )
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(avg_yearly=[/($0, 7.0)])
+- LogicalAggregate(group=[{}], agg#0=[SUM($0)])
   +- LogicalProject(l_extendedprice=[$5])
      +- LogicalFilter(condition=[AND(=($16, $1), =($19, 'Brand#13'), =($22, 'JUMBO CAN'), <($4, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*(0.2, $0)])
  LogicalAggregate(group=[{}], agg#0=[AVG($0)])
    LogicalProject(l_quantity=[$4])
      LogicalFilter(condition=[=($1, $cor0.p_partkey)])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[/($f0, 7.0) AS avg_yearly])
+- HashAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0])
   +- Exchange(distribution=[single])
      +- LocalHashAggregate(select=[Partial_SUM(l_extendedprice) AS sum$0])
         +- Calc(select=[l_extendedprice])
            +- HashJoin(where=[AND(<(l_quantity, *(0.2, $f1)), =(l_partkey, l_partkey0))], join=[l_partkey, $f1, l_partkey0, l_quantity, l_extendedprice], joinType=[InnerJoin], build=[right])
               :- HashAggregate(isMerge=[false], groupBy=[l_partkey], select=[l_partkey, AVG(l_quantity) AS $f1])
               :  +- Exchange(distribution=[hash[l_partkey]])
               :     +- Calc(select=[l_partkey, l_quantity], where=[RUNTIME_FILTER_0(l_partkey)])
               :        +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity];filterPredicates=[]]]], fields=[l_partkey, l_quantity])
               +- Calc(select=[l_partkey, l_quantity, l_extendedprice])
                  +- HashJoin(where=[=(p_partkey, l_partkey)], join=[l_partkey, l_quantity, l_extendedprice, p_partkey], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[l_partkey]])
                     :  +- Calc(select=[l_partkey, l_quantity, l_extendedprice], where=[RUNTIME_FILTER_0(l_partkey)])
                     :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity, l_extendedprice];filterPredicates=[]]]], fields=[l_partkey, l_quantity, l_extendedprice])
                     +- Exchange(distribution=[hash[p_partkey]])
                        +- Calc(select=[p_partkey], where=[AND(AND(=(p_brand, 'Brand#13'), =(p_container, 'JUMBO CAN')), RUNTIME_FILTER_BUILDER_0(p_partkey))])
                           +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_container];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_container])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=17, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch17 using 1395599672 as a seed to the RNG
select
  sum(l.l_extendedprice) / 7.0 as avg_yearly
from
  lineitem l,
  part p
where
  p.p_partkey = l.l_partkey
  and p.p_brand = 'Brand#13'
  and p.p_container = 'JUMBO CAN'
  and l.l_quantity < (
    select
      0.2 * avg(l2.l_quantity)
    from
      lineitem l2
    where
      l2.l_partkey = p.p_partkey
  )
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(avg_yearly=[/($0, 7.0)])
+- LogicalAggregate(group=[{}], agg#0=[SUM($0)])
   +- LogicalProject(l_extendedprice=[$5])
      +- LogicalFilter(condition=[AND(=($16, $1), =($19, 'Brand#13'), =($22, 'JUMBO CAN'), <($4, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*(0.2, $0)])
  LogicalAggregate(group=[{}], agg#0=[AVG($0)])
    LogicalProject(l_quantity=[$4])
      LogicalFilter(condition=[=($1, $cor0.p_partkey)])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[/($f0, 7.0) AS avg_yearly])
+- HashAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0])
   +- Exchange(distribution=[single])
      +- LocalHashAggregate(select=[Partial_SUM(l_extendedprice) AS sum$0])
         +- Calc(select=[l_extendedprice])
            +- HashJoin(where=[AND(<(l_quantity, *(0.2, $f1)), =(l_partkey, l_partkey0))], join=[l_partkey, l_quantity, l_extendedprice, l_partkey0, $f1], joinType=[InnerJoin], build=[right])
               :- Exchange(distribution=[hash[l_partkey]])
               :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity, l_extendedprice];filterPredicates=[]]]], fields=[l_partkey, l_quantity, l_extendedprice])
               +- Calc(select=[l_partkey, $f1])
                  +- HashJoin(where=[=(p_partkey, l_partkey)], join=[l_partkey, $f1, p_partkey], joinType=[InnerJoin], build=[right])
                     :- HashAggregate(isMerge=[true], groupBy=[l_partkey], select=[l_partkey, Final_AVG(sum$0, count$1) AS $f1])
                     :  +- Exchange(distribution=[hash[l_partkey]])
                     :     +- LocalHashAggregate(groupBy=[l_partkey], select=[l_partkey, Partial_AVG(l_quantity) AS (sum$0, count$1)])
                     :        +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity];filterPredicates=[]]]], fields=[l_partkey, l_quantity])
                     +- Exchange(distribution=[hash[p_partkey]])
                        +- Calc(select=[p_partkey], where=[AND(=(p_brand, 'Brand#13'), =(p_container, 'JUMBO CAN'))])
                           +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_container];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_container])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=17, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch17 using 1395599672 as a seed to the RNG
select
  sum(l.l_extendedprice) / 7.0 as avg_yearly
from
  lineitem l,
  part p
where
  p.p_partkey = l.l_partkey
  and p.p_brand = 'Brand#13'
  and p.p_container = 'JUMBO CAN'
  and l.l_quantity < (
    select
      0.2 * avg(l2.l_quantity)
    from
      lineitem l2
    where
      l2.l_partkey = p.p_partkey
  )
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(avg_yearly=[/($0, 7.0)])
+- LogicalAggregate(group=[{}], agg#0=[SUM($0)])
   +- LogicalProject(l_extendedprice=[$5])
      +- LogicalFilter(condition=[AND(=($16, $1), =($19, 'Brand#13'), =($22, 'JUMBO CAN'), <($4, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*(0.2, $0)])
  LogicalAggregate(group=[{}], agg#0=[AVG($0)])
    LogicalProject(l_quantity=[$4])
      LogicalFilter(condition=[=($1, $cor0.p_partkey)])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[/($f0, 7.0) AS avg_yearly])
+- HashAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS $f0])
   +- Exchange(distribution=[single])
      +- LocalHashAggregate(select=[Partial_SUM(l_extendedprice) AS sum$0])
         +- Calc(select=[l_extendedprice])
            +- HashJoin(where=[AND(<(l_quantity, *(0.2, $f1)), =(l_partkey, l_partkey0))], join=[l_partkey, l_quantity, l_extendedprice, l_partkey0, $f1], joinType=[InnerJoin], build=[right])
               :- Exchange(distribution=[hash[l_partkey]])
               :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity, l_extendedprice];filterPredicates=[]]]], fields=[l_partkey, l_quantity, l_extendedprice])
               +- Calc(select=[l_partkey, $f1])
                  +- HashJoin(where=[=(p_partkey, l_partkey)], join=[l_partkey, $f1, p_partkey], joinType=[InnerJoin], build=[right])
                     :- HashAggregate(isMerge=[true], groupBy=[l_partkey], select=[l_partkey, Final_AVG(sum$0, count$1) AS $f1])
                     :  +- Exchange(distribution=[hash[l_partkey]])
                     :     +- LocalHashAggregate(groupBy=[l_partkey], select=[l_partkey, Partial_AVG(l_quantity) AS (sum$0, count$1)])
                     :        +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity];filterPredicates=[]]]], fields=[l_partkey, l_quantity])
                     +- Exchange(distribution=[hash[p_partkey]])
                        +- Calc(select=[p_partkey], where=[AND(=(p_brand, 'Brand#13'), =(p_container, 'JUMBO CAN'))])
                           +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_container];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_container])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=18, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch18 using 1395599672 as a seed to the RNG
select
  c.c_name,
  c.c_custkey,
  o.o_orderkey,
  o.o_orderdate,
  o.o_totalprice,
  sum(l.l_quantity)
from
  customer c,
  orders o,
  lineitem l
where
  o.o_orderkey in (
    select
      l_orderkey
    from
      lineitem
    group by
      l_orderkey having
        sum(l_quantity) > 300
  )
  and c.c_custkey = o.o_custkey
  and o.o_orderkey = l.l_orderkey
group by
  c.c_name,
  c.c_custkey,
  o.o_orderkey,
  o.o_orderdate,
  o.o_totalprice
order by
  o.o_totalprice desc,
  o.o_orderdate
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$4], sort1=[$3], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[100])
+- LogicalAggregate(group=[{0, 1, 2, 3, 4}], EXPR$5=[SUM($5)])
   +- LogicalProject(c_name=[$1], c_custkey=[$0], o_orderkey=[$8], o_orderdate=[$12], o_totalprice=[$11], l_quantity=[$21])
      +- LogicalFilter(condition=[AND(IN($8, {
LogicalProject(l_orderkey=[$0])
  LogicalFilter(condition=[>($1, 300)])
    LogicalAggregate(group=[{0}], agg#0=[SUM($1)])
      LogicalProject(l_orderkey=[$0], l_quantity=[$4])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}), =($0, $9), =($8, $17))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, EXPR$5])
+- SortLimit(orderBy=[o_totalprice DESC, o_orderdate ASC], offset=[0], limit=[100], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[o_totalprice DESC, o_orderdate ASC], offset=[0], limit=[100], global=[false])
         +- HashAggregate(isMerge=[false], groupBy=[c_custkey, o_orderkey], auxGrouping=[c_name, o_orderdate, o_totalprice], select=[c_custkey, o_orderkey, c_name, o_orderdate, o_totalprice, SUM(l_quantity) AS EXPR$5])
            +- Calc(select=[c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, l_quantity])
               +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_quantity, o_orderkey, o_totalprice, o_orderdate, c_custkey, c_name], joinType=[InnerJoin], build=[right])
                  :- Exchange(distribution=[hash[l_orderkey]])
                  :  +- Calc(select=[l_orderkey, l_quantity], where=[RUNTIME_FILTER_2(l_orderkey)])
                  :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_quantity];filterPredicates=[]]]], fields=[l_orderkey, l_quantity])
                  +- Exchange(distribution=[hash[o_orderkey]])
                     +- Calc(select=[o_orderkey, o_totalprice, o_orderdate, c_custkey, c_name], where=[RUNTIME_FILTER_BUILDER_2(o_orderkey)])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, o_totalprice, o_orderdate, c_custkey, c_name], joinType=[InnerJoin], build=[left])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- HashSemiJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey, o_totalprice, o_orderdate], joinType=[LeftSemiJoin], build=[right])
                           :     :- Exchange(distribution=[hash[o_orderkey]])
                           :     :  +- Calc(select=[o_orderkey, o_custkey, o_totalprice, o_orderdate], where=[RUNTIME_FILTER_0(o_orderkey)])
                           :     :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_totalprice, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_totalprice, o_orderdate])
                           :     +- Calc(select=[l_orderkey], where=[AND(>($f1, 300), RUNTIME_FILTER_BUILDER_0(l_orderkey))])
                           :        +- HashAggregate(isMerge=[false], groupBy=[l_orderkey], select=[l_orderkey, SUM(l_quantity) AS $f1])
                           :           +- Exchange(distribution=[hash[l_orderkey]])
                           :              +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_quantity];filterPredicates=[]]]], fields=[l_orderkey, l_quantity])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name];filterPredicates=[]]]], fields=[c_custkey, c_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=18, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch18 using 1395599672 as a seed to the RNG
select
  c.c_name,
  c.c_custkey,
  o.o_orderkey,
  o.o_orderdate,
  o.o_totalprice,
  sum(l.l_quantity)
from
  customer c,
  orders o,
  lineitem l
where
  o.o_orderkey in (
    select
      l_orderkey
    from
      lineitem
    group by
      l_orderkey having
        sum(l_quantity) > 300
  )
  and c.c_custkey = o.o_custkey
  and o.o_orderkey = l.l_orderkey
group by
  c.c_name,
  c.c_custkey,
  o.o_orderkey,
  o.o_orderdate,
  o.o_totalprice
order by
  o.o_totalprice desc,
  o.o_orderdate
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$4], sort1=[$3], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[100])
+- LogicalAggregate(group=[{0, 1, 2, 3, 4}], EXPR$5=[SUM($5)])
   +- LogicalProject(c_name=[$1], c_custkey=[$0], o_orderkey=[$8], o_orderdate=[$12], o_totalprice=[$11], l_quantity=[$21])
      +- LogicalFilter(condition=[AND(IN($8, {
LogicalProject(l_orderkey=[$0])
  LogicalFilter(condition=[>($1, 300)])
    LogicalAggregate(group=[{0}], agg#0=[SUM($1)])
      LogicalProject(l_orderkey=[$0], l_quantity=[$4])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}), =($0, $9), =($8, $17))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, EXPR$5])
+- SortLimit(orderBy=[o_totalprice DESC, o_orderdate ASC], offset=[0], limit=[100], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[o_totalprice DESC, o_orderdate ASC], offset=[0], limit=[100], global=[false])
         +- HashAggregate(isMerge=[false], groupBy=[c_custkey, o_orderkey], auxGrouping=[c_name, o_orderdate, o_totalprice], select=[c_custkey, o_orderkey, c_name, o_orderdate, o_totalprice, SUM(l_quantity) AS EXPR$5])
            +- Calc(select=[c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, l_quantity])
               +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_quantity, o_orderkey, o_totalprice, o_orderdate, c_custkey, c_name], joinType=[InnerJoin], build=[right])
                  :- Exchange(distribution=[hash[l_orderkey]])
                  :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_quantity];filterPredicates=[]]]], fields=[l_orderkey, l_quantity])
                  +- Exchange(distribution=[hash[o_orderkey]])
                     +- Calc(select=[o_orderkey, o_totalprice, o_orderdate, c_custkey, c_name])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, o_totalprice, o_orderdate, c_custkey, c_name], joinType=[InnerJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- HashSemiJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey, o_totalprice, o_orderdate], joinType=[LeftSemiJoin], build=[right])
                           :     :- Exchange(distribution=[hash[o_orderkey]])
                           :     :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_totalprice, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_totalprice, o_orderdate])
                           :     +- Calc(select=[l_orderkey], where=[>($f1, 300)])
                           :        +- HashAggregate(isMerge=[true], groupBy=[l_orderkey], select=[l_orderkey, Final_SUM(sum$0) AS $f1])
                           :           +- Exchange(distribution=[hash[l_orderkey]])
                           :              +- LocalHashAggregate(groupBy=[l_orderkey], select=[l_orderkey, Partial_SUM(l_quantity) AS sum$0])
                           :                 +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_quantity];filterPredicates=[]]]], fields=[l_orderkey, l_quantity])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name];filterPredicates=[]]]], fields=[c_custkey, c_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=18, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch18 using 1395599672 as a seed to the RNG
select
  c.c_name,
  c.c_custkey,
  o.o_orderkey,
  o.o_orderdate,
  o.o_totalprice,
  sum(l.l_quantity)
from
  customer c,
  orders o,
  lineitem l
where
  o.o_orderkey in (
    select
      l_orderkey
    from
      lineitem
    group by
      l_orderkey having
        sum(l_quantity) > 300
  )
  and c.c_custkey = o.o_custkey
  and o.o_orderkey = l.l_orderkey
group by
  c.c_name,
  c.c_custkey,
  o.o_orderkey,
  o.o_orderdate,
  o.o_totalprice
order by
  o.o_totalprice desc,
  o.o_orderdate
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$4], sort1=[$3], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[100])
+- LogicalAggregate(group=[{0, 1, 2, 3, 4}], EXPR$5=[SUM($5)])
   +- LogicalProject(c_name=[$1], c_custkey=[$0], o_orderkey=[$8], o_orderdate=[$12], o_totalprice=[$11], l_quantity=[$21])
      +- LogicalFilter(condition=[AND(IN($8, {
LogicalProject(l_orderkey=[$0])
  LogicalFilter(condition=[>($1, 300)])
    LogicalAggregate(group=[{0}], agg#0=[SUM($1)])
      LogicalProject(l_orderkey=[$0], l_quantity=[$4])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}), =($0, $9), =($8, $17))])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, EXPR$5])
+- SortLimit(orderBy=[o_totalprice DESC, o_orderdate ASC], offset=[0], limit=[100], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[o_totalprice DESC, o_orderdate ASC], offset=[0], limit=[100], global=[false])
         +- HashAggregate(isMerge=[false], groupBy=[c_custkey, o_orderkey], auxGrouping=[c_name, o_orderdate, o_totalprice], select=[c_custkey, o_orderkey, c_name, o_orderdate, o_totalprice, SUM(l_quantity) AS EXPR$5])
            +- Calc(select=[c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, l_quantity])
               +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_quantity, o_orderkey, o_totalprice, o_orderdate, c_custkey, c_name], joinType=[InnerJoin], build=[right])
                  :- Exchange(distribution=[hash[l_orderkey]])
                  :  +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_quantity];filterPredicates=[]]]], fields=[l_orderkey, l_quantity])
                  +- Exchange(distribution=[hash[o_orderkey]])
                     +- Calc(select=[o_orderkey, o_totalprice, o_orderdate, c_custkey, c_name])
                        +- HashJoin(where=[=(c_custkey, o_custkey)], join=[o_orderkey, o_custkey, o_totalprice, o_orderdate, c_custkey, c_name], joinType=[InnerJoin], build=[right])
                           :- Exchange(distribution=[hash[o_custkey]])
                           :  +- HashSemiJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey, o_totalprice, o_orderdate], joinType=[LeftSemiJoin], build=[right])
                           :     :- Exchange(distribution=[hash[o_orderkey]])
                           :     :  +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_totalprice, o_orderdate];filterPredicates=[]]]], fields=[o_orderkey, o_custkey, o_totalprice, o_orderdate])
                           :     +- Calc(select=[l_orderkey], where=[>($f1, 300)])
                           :        +- HashAggregate(isMerge=[true], groupBy=[l_orderkey], select=[l_orderkey, Final_SUM(sum$0) AS $f1])
                           :           +- Exchange(distribution=[hash[l_orderkey]])
                           :              +- LocalHashAggregate(groupBy=[l_orderkey], select=[l_orderkey, Partial_SUM(l_quantity) AS sum$0])
                           :                 +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_quantity];filterPredicates=[]]]], fields=[l_orderkey, l_quantity])
                           +- Exchange(distribution=[hash[c_custkey]])
                              +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name];filterPredicates=[]]]], fields=[c_custkey, c_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=19, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch19 using 1395599672 as a seed to the RNG
select
  sum(l.l_extendedprice* (1 - l.l_discount)) as revenue
from
  lineitem l,
  part p
where
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#41'
    and p.p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
    and l.l_quantity >= 2 and l.l_quantity <= 2 + 10
    and p.p_size between 1 and 5
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
  or
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#13'
    and p.p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
    and l.l_quantity >= 14 and l.l_quantity <= 14 + 10
    and p.p_size between 1 and 10
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
  or
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#55'
    and p.p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
    and l.l_quantity >= 23 and l.l_quantity <= 23 + 10
    and p.p_size between 1 and 15
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{}], revenue=[SUM($0)])
+- LogicalProject($f0=[*($5, -(1, $6))])
   +- LogicalFilter(condition=[OR(AND(=($16, $1), =($19, 'Brand#41'), OR(=($22, 'SM CASE'), =($22, 'SM BOX'), =($22, 'SM PACK'), =($22, 'SM PKG')), >=($4, 2), <=($4, +(2, 10)), >=($21, 1), <=($21, 5), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')), AND(=($16, $1), =($19, 'Brand#13'), OR(=($22, 'MED BAG'), =($22, 'MED BOX'), =($22, 'MED PKG'), =($22, 'MED PACK')), >=($4, 14), <=($4, +(14, 10)), >=($21, 1), <=($21, 10), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')), AND(=($16, $1), =($19, 'Brand#55'), OR(=($22, 'LG CASE'), =($22, 'LG BOX'), =($22, 'LG PACK'), =($22, 'LG PKG')), >=($4, 23), <=($4, +(23, 10)), >=($21, 1), <=($21, 15), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS revenue])
+- Exchange(distribution=[single])
   +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
      +- Calc(select=[*(l_extendedprice, -(1, l_discount)) AS $f0])
         +- HashJoin(where=[AND(=(p_partkey, l_partkey), OR(AND(=(p_brand, 'Brand#41'), IN(p_container, 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG'), >=(l_quantity, 2), <=(l_quantity, 12), <=(p_size, 5)), AND(=(p_brand, 'Brand#13'), IN(p_container, 'MED BAG', 'MED BOX', 'MED PKG', 'MED PACK'), >=(l_quantity, 14), <=(l_quantity, 24), <=(p_size, 10)), AND(=(p_brand, 'Brand#55'), IN(p_container, 'LG CASE', 'LG BOX', 'LG PACK', 'LG PKG'), >=(l_quantity, 23), <=(l_quantity, 33), <=(p_size, 15))))], join=[l_partkey, l_quantity, l_extendedprice, l_discount, p_partkey, p_brand, p_size, p_container], joinType=[InnerJoin], build=[right])
            :- Exchange(distribution=[hash[l_partkey]])
            :  +- Calc(select=[l_partkey, l_quantity, l_extendedprice, l_discount], where=[AND(OR(=(l_shipmode, 'AIR'), =(l_shipmode, 'AIR REG')), =(l_shipinstruct, 'DELIVER IN PERSON'), OR(AND(>=(l_quantity, 2), <=(l_quantity, 12)), AND(>=(l_quantity, 14), <=(l_quantity, 24)), AND(>=(l_quantity, 23), <=(l_quantity, 33))), RUNTIME_FILTER_0(l_partkey))])
            :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode];filterPredicates=[]]]], fields=[l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode])
            +- Exchange(distribution=[hash[p_partkey]])
               +- Calc(select=[p_partkey, p_brand, p_size, p_container], where=[AND(>=(p_size, 1), OR(AND(=(p_brand, 'Brand#41'), IN(p_container, 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG'), <=(p_size, 5)), AND(=(p_brand, 'Brand#13'), IN(p_container, 'MED BAG', 'MED BOX', 'MED PKG', 'MED PACK'), <=(p_size, 10)), AND(=(p_brand, 'Brand#55'), IN(p_container, 'LG CASE', 'LG BOX', 'LG PACK', 'LG PKG'), <=(p_size, 15))), RUNTIME_FILTER_BUILDER_0(p_partkey))])
                  +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_size, p_container];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_size, p_container])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=19, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch19 using 1395599672 as a seed to the RNG
select
  sum(l.l_extendedprice* (1 - l.l_discount)) as revenue
from
  lineitem l,
  part p
where
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#41'
    and p.p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
    and l.l_quantity >= 2 and l.l_quantity <= 2 + 10
    and p.p_size between 1 and 5
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
  or
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#13'
    and p.p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
    and l.l_quantity >= 14 and l.l_quantity <= 14 + 10
    and p.p_size between 1 and 10
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
  or
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#55'
    and p.p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
    and l.l_quantity >= 23 and l.l_quantity <= 23 + 10
    and p.p_size between 1 and 15
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{}], revenue=[SUM($0)])
+- LogicalProject($f0=[*($5, -(1, $6))])
   +- LogicalFilter(condition=[OR(AND(=($16, $1), =($19, 'Brand#41'), OR(=($22, 'SM CASE'), =($22, 'SM BOX'), =($22, 'SM PACK'), =($22, 'SM PKG')), >=($4, 2), <=($4, +(2, 10)), >=($21, 1), <=($21, 5), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')), AND(=($16, $1), =($19, 'Brand#13'), OR(=($22, 'MED BAG'), =($22, 'MED BOX'), =($22, 'MED PKG'), =($22, 'MED PACK')), >=($4, 14), <=($4, +(14, 10)), >=($21, 1), <=($21, 10), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')), AND(=($16, $1), =($19, 'Brand#55'), OR(=($22, 'LG CASE'), =($22, 'LG BOX'), =($22, 'LG PACK'), =($22, 'LG PKG')), >=($4, 23), <=($4, +(23, 10)), >=($21, 1), <=($21, 15), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS revenue])
+- Exchange(distribution=[single])
   +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
      +- Calc(select=[*(l_extendedprice, -(1, l_discount)) AS $f0])
         +- HashJoin(where=[AND(=(p_partkey, l_partkey), OR(AND(=(p_brand, 'Brand#41'), IN(p_container, 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG'), >=(l_quantity, 2), <=(l_quantity, 12), <=(p_size, 5)), AND(=(p_brand, 'Brand#13'), IN(p_container, 'MED BAG', 'MED BOX', 'MED PKG', 'MED PACK'), >=(l_quantity, 14), <=(l_quantity, 24), <=(p_size, 10)), AND(=(p_brand, 'Brand#55'), IN(p_container, 'LG CASE', 'LG BOX', 'LG PACK', 'LG PKG'), >=(l_quantity, 23), <=(l_quantity, 33), <=(p_size, 15))))], join=[l_partkey, l_quantity, l_extendedprice, l_discount, p_partkey, p_brand, p_size, p_container], joinType=[InnerJoin], build=[right])
            :- Exchange(distribution=[hash[l_partkey]])
            :  +- Calc(select=[l_partkey, l_quantity, l_extendedprice, l_discount], where=[AND(OR(=(l_shipmode, 'AIR'), =(l_shipmode, 'AIR REG')), =(l_shipinstruct, 'DELIVER IN PERSON'), OR(AND(>=(l_quantity, 2), <=(l_quantity, 12)), AND(>=(l_quantity, 14), <=(l_quantity, 24)), AND(>=(l_quantity, 23), <=(l_quantity, 33))))])
            :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode];filterPredicates=[]]]], fields=[l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode])
            +- Exchange(distribution=[hash[p_partkey]])
               +- Calc(select=[p_partkey, p_brand, p_size, p_container], where=[AND(>=(p_size, 1), OR(AND(=(p_brand, 'Brand#41'), IN(p_container, 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG'), <=(p_size, 5)), AND(=(p_brand, 'Brand#13'), IN(p_container, 'MED BAG', 'MED BOX', 'MED PKG', 'MED PACK'), <=(p_size, 10)), AND(=(p_brand, 'Brand#55'), IN(p_container, 'LG CASE', 'LG BOX', 'LG PACK', 'LG PKG'), <=(p_size, 15))))])
                  +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_size, p_container];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_size, p_container])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=19, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch19 using 1395599672 as a seed to the RNG
select
  sum(l.l_extendedprice* (1 - l.l_discount)) as revenue
from
  lineitem l,
  part p
where
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#41'
    and p.p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
    and l.l_quantity >= 2 and l.l_quantity <= 2 + 10
    and p.p_size between 1 and 5
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
  or
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#13'
    and p.p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
    and l.l_quantity >= 14 and l.l_quantity <= 14 + 10
    and p.p_size between 1 and 10
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
  or
  (
    p.p_partkey = l.l_partkey
    and p.p_brand = 'Brand#55'
    and p.p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
    and l.l_quantity >= 23 and l.l_quantity <= 23 + 10
    and p.p_size between 1 and 15
    and l.l_shipmode in ('AIR', 'AIR REG')
    and l.l_shipinstruct = 'DELIVER IN PERSON'
  )
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{}], revenue=[SUM($0)])
+- LogicalProject($f0=[*($5, -(1, $6))])
   +- LogicalFilter(condition=[OR(AND(=($16, $1), =($19, 'Brand#41'), OR(=($22, 'SM CASE'), =($22, 'SM BOX'), =($22, 'SM PACK'), =($22, 'SM PKG')), >=($4, 2), <=($4, +(2, 10)), >=($21, 1), <=($21, 5), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')), AND(=($16, $1), =($19, 'Brand#13'), OR(=($22, 'MED BAG'), =($22, 'MED BOX'), =($22, 'MED PKG'), =($22, 'MED PACK')), >=($4, 14), <=($4, +(14, 10)), >=($21, 1), <=($21, 10), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')), AND(=($16, $1), =($19, 'Brand#55'), OR(=($22, 'LG CASE'), =($22, 'LG BOX'), =($22, 'LG PACK'), =($22, 'LG PKG')), >=($4, 23), <=($4, +(23, 10)), >=($21, 1), <=($21, 15), OR(=($14, 'AIR'), =($14, 'AIR REG')), =($13, 'DELIVER IN PERSON')))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortAggregate(isMerge=[true], select=[Final_SUM(sum$0) AS revenue])
+- Exchange(distribution=[single])
   +- LocalSortAggregate(select=[Partial_SUM($f0) AS sum$0])
      +- Calc(select=[*(l_extendedprice, -(1, l_discount)) AS $f0])
         +- HashJoin(where=[AND(=(p_partkey, l_partkey), OR(AND(=(p_brand, 'Brand#41'), IN(p_container, 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG'), >=(l_quantity, 2), <=(l_quantity, 12), <=(p_size, 5)), AND(=(p_brand, 'Brand#13'), IN(p_container, 'MED BAG', 'MED BOX', 'MED PKG', 'MED PACK'), >=(l_quantity, 14), <=(l_quantity, 24), <=(p_size, 10)), AND(=(p_brand, 'Brand#55'), IN(p_container, 'LG CASE', 'LG BOX', 'LG PACK', 'LG PKG'), >=(l_quantity, 23), <=(l_quantity, 33), <=(p_size, 15))))], join=[l_partkey, l_quantity, l_extendedprice, l_discount, p_partkey, p_brand, p_size, p_container], joinType=[InnerJoin], build=[right])
            :- Exchange(distribution=[hash[l_partkey]])
            :  +- Calc(select=[l_partkey, l_quantity, l_extendedprice, l_discount], where=[AND(OR(=(l_shipmode, 'AIR'), =(l_shipmode, 'AIR REG')), =(l_shipinstruct, 'DELIVER IN PERSON'), OR(AND(>=(l_quantity, 2), <=(l_quantity, 12)), AND(>=(l_quantity, 14), <=(l_quantity, 24)), AND(>=(l_quantity, 23), <=(l_quantity, 33))))])
            :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode];filterPredicates=[]]]], fields=[l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode])
            +- Exchange(distribution=[hash[p_partkey]])
               +- Calc(select=[p_partkey, p_brand, p_size, p_container], where=[AND(>=(p_size, 1), OR(AND(=(p_brand, 'Brand#41'), IN(p_container, 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG'), <=(p_size, 5)), AND(=(p_brand, 'Brand#13'), IN(p_container, 'MED BAG', 'MED BOX', 'MED PKG', 'MED PACK'), <=(p_size, 10)), AND(=(p_brand, 'Brand#55'), IN(p_container, 'LG CASE', 'LG BOX', 'LG PACK', 'LG PKG'), <=(p_size, 15))))])
                  +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_brand, p_size, p_container];filterPredicates=[]]]], fields=[p_partkey, p_brand, p_size, p_container])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=20, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch20 using 1395599672 as a seed to the RNG
select
  s.s_name,
  s.s_address
from
  supplier s,
  nation n
where
  s.s_suppkey in (
    select
      ps.ps_suppkey
    from
      partsupp ps
    where
      ps. ps_partkey in (
        select
          p.p_partkey
        from
          part p
        where
          p.p_name like 'antique%'
      )
      and ps.ps_availqty > (
        select
          0.5 * sum(l.l_quantity)
        from
          lineitem l
        where
          l.l_partkey = ps.ps_partkey
          and l.l_suppkey = ps.ps_suppkey
          and l.l_shipdate >= date '1993-01-01'
          and l.l_shipdate < date '1993-01-01' + interval '1' year
      )
  )
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'KENYA'
order by
  s.s_name
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(s_name=[$1], s_address=[$2])
   +- LogicalFilter(condition=[AND(IN($0, {
LogicalProject(ps_suppkey=[$1])
  LogicalFilter(condition=[AND(IN($0, {
LogicalProject(p_partkey=[$0])
  LogicalFilter(condition=[LIKE($1, 'antique%')])
    LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
}), >($2, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*(0.5, $0)])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)])
    LogicalProject(l_quantity=[$4])
      LogicalFilter(condition=[AND(=($1, $cor0.ps_partkey), =($2, $cor0.ps_suppkey), >=($10, 1993-01-01), <($10, +(1993-01-01, 12)))])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
    LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
}), =($3, $7), =($8, 'KENYA'))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_name, s_address])
+- SortLimit(orderBy=[s_name ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_name ASC], offset=[0], limit=[200], global=[false])
         +- HashSemiJoin(where=[=(s_suppkey, ps_suppkey)], join=[s_suppkey, s_name, s_address], joinType=[LeftSemiJoin], build=[left], tryDistinctBuildRow=[true])
            :- Exchange(distribution=[hash[s_suppkey]])
            :  +- Calc(select=[s_suppkey, s_name, s_address])
            :     +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_name, s_address, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
            :        :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_nationkey])
            :        +- Exchange(distribution=[broadcast])
            :           +- Calc(select=[n_nationkey], where=[=(n_name, 'KENYA')])
            :              +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
            +- Exchange(distribution=[hash[ps_suppkey]])
               +- LocalHashAggregate(groupBy=[ps_suppkey], select=[ps_suppkey])
                  +- Calc(select=[ps_suppkey])
                     +- HashJoin(where=[AND(=(ps_partkey, l_partkey), =(ps_suppkey, l_suppkey), >(ps_availqty, *(0.5, $f2)))], join=[l_partkey, l_suppkey, $f2, ps_partkey, ps_suppkey, ps_availqty], joinType=[InnerJoin], build=[right])
                        :- HashAggregate(isMerge=[false], groupBy=[l_partkey, l_suppkey], select=[l_partkey, l_suppkey, SUM(l_quantity) AS $f2])
                        :  +- Exchange(distribution=[hash[l_partkey, l_suppkey]])
                        :     +- Calc(select=[l_partkey, l_suppkey, l_quantity], where=[AND(AND(>=(l_shipdate, 1993-01-01), <(l_shipdate, 1994-01-01)), RUNTIME_FILTER_0(l_partkey))])
                        :        +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_suppkey, l_quantity, l_shipdate];filterPredicates=[]]]], fields=[l_partkey, l_suppkey, l_quantity, l_shipdate])
                        +- Exchange(distribution=[hash[ps_partkey, ps_suppkey]])
                           +- HashSemiJoin(where=[=(ps_partkey, p_partkey)], join=[ps_partkey, ps_suppkey, ps_availqty], joinType=[LeftSemiJoin], build=[right])
                              :- Exchange(distribution=[hash[ps_partkey]])
                              :  +- Calc(select=[ps_partkey, ps_suppkey, ps_availqty], where=[RUNTIME_FILTER_0(ps_partkey)])
                              :     +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty])
                              +- Exchange(distribution=[hash[p_partkey]])
                                 +- Calc(select=[p_partkey], where=[AND(LIKE(p_name, 'antique%'), RUNTIME_FILTER_BUILDER_0(p_partkey))])
                                    +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name];filterPredicates=[]]]], fields=[p_partkey, p_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=20, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch20 using 1395599672 as a seed to the RNG
select
  s.s_name,
  s.s_address
from
  supplier s,
  nation n
where
  s.s_suppkey in (
    select
      ps.ps_suppkey
    from
      partsupp ps
    where
      ps. ps_partkey in (
        select
          p.p_partkey
        from
          part p
        where
          p.p_name like 'antique%'
      )
      and ps.ps_availqty > (
        select
          0.5 * sum(l.l_quantity)
        from
          lineitem l
        where
          l.l_partkey = ps.ps_partkey
          and l.l_suppkey = ps.ps_suppkey
          and l.l_shipdate >= date '1993-01-01'
          and l.l_shipdate < date '1993-01-01' + interval '1' year
      )
  )
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'KENYA'
order by
  s.s_name
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(s_name=[$1], s_address=[$2])
   +- LogicalFilter(condition=[AND(IN($0, {
LogicalProject(ps_suppkey=[$1])
  LogicalFilter(condition=[AND(IN($0, {
LogicalProject(p_partkey=[$0])
  LogicalFilter(condition=[LIKE($1, 'antique%')])
    LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
}), >($2, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*(0.5, $0)])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)])
    LogicalProject(l_quantity=[$4])
      LogicalFilter(condition=[AND(=($1, $cor0.ps_partkey), =($2, $cor0.ps_suppkey), >=($10, 1993-01-01), <($10, +(1993-01-01, 12)))])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
    LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
}), =($3, $7), =($8, 'KENYA'))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_name, s_address])
+- SortLimit(orderBy=[s_name ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_name ASC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_name, s_address, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
            :- Calc(select=[s_name, s_address, s_nationkey])
            :  +- HashSemiJoin(where=[=(s_suppkey, ps_suppkey)], join=[s_suppkey, s_name, s_address, s_nationkey], joinType=[LeftSemiJoin], build=[right])
            :     :- Exchange(distribution=[hash[s_suppkey]])
            :     :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_nationkey])
            :     +- Exchange(distribution=[hash[ps_suppkey]])
            :        +- Calc(select=[ps_suppkey])
            :           +- HashJoin(where=[AND(=(ps_partkey, l_partkey), =(ps_suppkey, l_suppkey), >(ps_availqty, *(0.5, $f2)))], join=[l_partkey, l_suppkey, $f2, ps_partkey, ps_suppkey, ps_availqty], joinType=[InnerJoin], build=[right])
            :              :- HashAggregate(isMerge=[true], groupBy=[l_partkey, l_suppkey], select=[l_partkey, l_suppkey, Final_SUM(sum$0) AS $f2])
            :              :  +- Exchange(distribution=[hash[l_partkey, l_suppkey]])
            :              :     +- LocalHashAggregate(groupBy=[l_partkey, l_suppkey], select=[l_partkey, l_suppkey, Partial_SUM(l_quantity) AS sum$0])
            :              :        +- Calc(select=[l_partkey, l_suppkey, l_quantity], where=[AND(>=(l_shipdate, 1993-01-01), <(l_shipdate, 1994-01-01))])
            :              :           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_suppkey, l_quantity, l_shipdate];filterPredicates=[]]]], fields=[l_partkey, l_suppkey, l_quantity, l_shipdate])
            :              +- Exchange(distribution=[hash[ps_partkey, ps_suppkey]])
            :                 +- HashSemiJoin(where=[=(ps_partkey, p_partkey)], join=[ps_partkey, ps_suppkey, ps_availqty], joinType=[LeftSemiJoin], build=[right])
            :                    :- Exchange(distribution=[hash[ps_partkey]])
            :                    :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty])
            :                    +- Exchange(distribution=[hash[p_partkey]])
            :                       +- Calc(select=[p_partkey], where=[LIKE(p_name, 'antique%')])
            :                          +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name];filterPredicates=[]]]], fields=[p_partkey, p_name])
            +- Exchange(distribution=[broadcast])
               +- Calc(select=[n_nationkey], where=[=(n_name, 'KENYA')])
                  +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=20, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch20 using 1395599672 as a seed to the RNG
select
  s.s_name,
  s.s_address
from
  supplier s,
  nation n
where
  s.s_suppkey in (
    select
      ps.ps_suppkey
    from
      partsupp ps
    where
      ps. ps_partkey in (
        select
          p.p_partkey
        from
          part p
        where
          p.p_name like 'antique%'
      )
      and ps.ps_availqty > (
        select
          0.5 * sum(l.l_quantity)
        from
          lineitem l
        where
          l.l_partkey = ps.ps_partkey
          and l.l_suppkey = ps.ps_suppkey
          and l.l_shipdate >= date '1993-01-01'
          and l.l_shipdate < date '1993-01-01' + interval '1' year
      )
  )
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'KENYA'
order by
  s.s_name
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalProject(s_name=[$1], s_address=[$2])
   +- LogicalFilter(condition=[AND(IN($0, {
LogicalProject(ps_suppkey=[$1])
  LogicalFilter(condition=[AND(IN($0, {
LogicalProject(p_partkey=[$0])
  LogicalFilter(condition=[LIKE($1, 'antique%')])
    LogicalTableScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment];filterPredicates=[]]]])
}), >($2, $SCALAR_QUERY({
LogicalProject(EXPR$0=[*(0.5, $0)])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)])
    LogicalProject(l_quantity=[$4])
      LogicalFilter(condition=[AND(=($1, $cor0.ps_partkey), =($2, $cor0.ps_suppkey), >=($10, 1993-01-01), <($10, +(1993-01-01, 12)))])
        LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
    LogicalTableScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment];filterPredicates=[]]]])
}), =($3, $7), =($8, 'KENYA'))])
      +- LogicalJoin(condition=[true], joinType=[inner])
         :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
         +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[s_name, s_address])
+- SortLimit(orderBy=[s_name ASC], offset=[0], limit=[200], global=[true])
   +- Exchange(distribution=[single])
      +- SortLimit(orderBy=[s_name ASC], offset=[0], limit=[200], global=[false])
         +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_name, s_address, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
            :- Calc(select=[s_name, s_address, s_nationkey])
            :  +- HashSemiJoin(where=[=(s_suppkey, ps_suppkey)], join=[s_suppkey, s_name, s_address, s_nationkey], joinType=[LeftSemiJoin], build=[right])
            :     :- Exchange(distribution=[hash[s_suppkey]])
            :     :  +- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_address, s_nationkey])
            :     +- Exchange(distribution=[hash[ps_suppkey]])
            :        +- Calc(select=[ps_suppkey])
            :           +- HashJoin(where=[AND(=(ps_partkey, l_partkey), =(ps_suppkey, l_suppkey), >(ps_availqty, *(0.5, $f2)))], join=[l_partkey, l_suppkey, $f2, ps_partkey, ps_suppkey, ps_availqty], joinType=[InnerJoin], build=[right])
            :              :- HashAggregate(isMerge=[true], groupBy=[l_partkey, l_suppkey], select=[l_partkey, l_suppkey, Final_SUM(sum$0) AS $f2])
            :              :  +- Exchange(distribution=[hash[l_partkey, l_suppkey]])
            :              :     +- LocalHashAggregate(groupBy=[l_partkey, l_suppkey], select=[l_partkey, l_suppkey, Partial_SUM(l_quantity) AS sum$0])
            :              :        +- Calc(select=[l_partkey, l_suppkey, l_quantity], where=[AND(>=(l_shipdate, 1993-01-01), <(l_shipdate, 1994-01-01))])
            :              :           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_partkey, l_suppkey, l_quantity, l_shipdate];filterPredicates=[]]]], fields=[l_partkey, l_suppkey, l_quantity, l_shipdate])
            :              +- Exchange(distribution=[hash[ps_partkey, ps_suppkey]])
            :                 +- HashSemiJoin(where=[=(ps_partkey, p_partkey)], join=[ps_partkey, ps_suppkey, ps_availqty], joinType=[LeftSemiJoin], build=[right])
            :                    :- Exchange(distribution=[hash[ps_partkey]])
            :                    :  +- TableSourceScan(table=[[builtin, default, partsupp, source: [TestParquetTableSource -> selectedFields=[ps_partkey, ps_suppkey, ps_availqty];filterPredicates=[]]]], fields=[ps_partkey, ps_suppkey, ps_availqty])
            :                    +- Exchange(distribution=[hash[p_partkey]])
            :                       +- Calc(select=[p_partkey], where=[LIKE(p_name, 'antique%')])
            :                          +- TableSourceScan(table=[[builtin, default, part, source: [TestParquetTableSource -> selectedFields=[p_partkey, p_name];filterPredicates=[]]]], fields=[p_partkey, p_name])
            +- Exchange(distribution=[broadcast])
               +- Calc(select=[n_nationkey], where=[=(n_name, 'KENYA')])
                  +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=21, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch21 using 1395599672 as a seed to the RNG
select
  s.s_name,
  count(*) as numwait
from
  supplier s,
  lineitem l1,
  orders o,
  nation n
where
  s.s_suppkey = l1.l_suppkey
  and o.o_orderkey = l1.l_orderkey
  and o.o_orderstatus = 'F'
  and l1.l_receiptdate > l1.l_commitdate
  and exists (
    select
      *
    from
      lineitem l2
    where
      l2.l_orderkey = l1.l_orderkey
      and l2.l_suppkey <> l1.l_suppkey
  )
  and not exists (
    select
      *
    from
      lineitem l3
    where
      l3.l_orderkey = l1.l_orderkey
      and l3.l_suppkey <> l1.l_suppkey
      and l3.l_receiptdate > l3.l_commitdate
  )
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'BRAZIL'
group by
  s.s_name
order by
  numwait desc,
  s.s_name
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$0], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[100])
+- LogicalAggregate(group=[{0}], numwait=[COUNT()])
   +- LogicalProject(s_name=[$1])
      +- LogicalFilter(condition=[AND(=($0, $9), =($23, $7), =($25, 'F'), >($19, $18), EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.l_orderkey), <>($2, $cor0.l_suppkey))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}), NOT(EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.l_orderkey), <>($2, $cor0.l_suppkey), >($12, $11))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})), =($3, $32), =($33, 'BRAZIL'))], variablesSet=[[$cor0]])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[numwait DESC, s_name ASC], offset=[0], limit=[100], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[numwait DESC, s_name ASC], offset=[0], limit=[100], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[s_name], select=[s_name, Final_COUNT(count$0) AS numwait])
         +- Exchange(distribution=[hash[s_name]])
            +- LocalHashAggregate(groupBy=[s_name], select=[s_name, Partial_COUNT(*) AS count$0])
               +- Calc(select=[s_name])
                  +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, l_orderkey, s_name], joinType=[InnerJoin], build=[right])
                     :- Exchange(distribution=[hash[o_orderkey]])
                     :  +- Calc(select=[o_orderkey], where=[=(o_orderstatus, 'F')])
                     :     +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderstatus];filterPredicates=[]]]], fields=[o_orderkey, o_orderstatus])
                     +- Calc(select=[l_orderkey, s_name])
                        +- HashSemiJoin(where=[AND(=(l_orderkey0, l_orderkey), <>(l_suppkey0, l_suppkey))], join=[l_orderkey, l_suppkey, s_name], joinType=[LeftAntiJoin], build=[left])
                           :- HashSemiJoin(where=[AND(=(l_orderkey0, l_orderkey), <>(l_suppkey0, l_suppkey))], join=[l_orderkey, l_suppkey, s_name], joinType=[LeftSemiJoin], build=[left])
                           :  :- Exchange(distribution=[hash[l_orderkey]])
                           :  :  +- Calc(select=[l_orderkey, l_suppkey, s_name])
                           :  :     +- HashJoin(where=[=(s_suppkey, l_suppkey)], join=[l_orderkey, l_suppkey, s_suppkey, s_name], joinType=[InnerJoin], build=[right])
                           :  :        :- Exchange(distribution=[hash[l_suppkey]])
                           :  :        :  +- Calc(select=[l_orderkey, l_suppkey], where=[AND(>(l_receiptdate, l_commitdate), RUNTIME_FILTER_0(l_suppkey))])
                           :  :        :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate])
                           :  :        +- Exchange(distribution=[hash[s_suppkey]])
                           :  :           +- Calc(select=[s_suppkey, s_name], where=[RUNTIME_FILTER_BUILDER_0(s_suppkey)])
                           :  :              +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_name, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
                           :  :                 :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_nationkey])
                           :  :                 +- Exchange(distribution=[broadcast])
                           :  :                    +- Calc(select=[n_nationkey], where=[=(n_name, 'BRAZIL')])
                           :  :                       +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                           :  +- Exchange(distribution=[hash[l_orderkey]])
                           :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey])
                           +- Exchange(distribution=[hash[l_orderkey]])
                              +- Calc(select=[l_orderkey, l_suppkey], where=[>(l_receiptdate, l_commitdate)])
                                 +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=21, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch21 using 1395599672 as a seed to the RNG
select
  s.s_name,
  count(*) as numwait
from
  supplier s,
  lineitem l1,
  orders o,
  nation n
where
  s.s_suppkey = l1.l_suppkey
  and o.o_orderkey = l1.l_orderkey
  and o.o_orderstatus = 'F'
  and l1.l_receiptdate > l1.l_commitdate
  and exists (
    select
      *
    from
      lineitem l2
    where
      l2.l_orderkey = l1.l_orderkey
      and l2.l_suppkey <> l1.l_suppkey
  )
  and not exists (
    select
      *
    from
      lineitem l3
    where
      l3.l_orderkey = l1.l_orderkey
      and l3.l_suppkey <> l1.l_suppkey
      and l3.l_receiptdate > l3.l_commitdate
  )
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'BRAZIL'
group by
  s.s_name
order by
  numwait desc,
  s.s_name
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$0], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[100])
+- LogicalAggregate(group=[{0}], numwait=[COUNT()])
   +- LogicalProject(s_name=[$1])
      +- LogicalFilter(condition=[AND(=($0, $9), =($23, $7), =($25, 'F'), >($19, $18), EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.l_orderkey), <>($2, $cor0.l_suppkey))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}), NOT(EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.l_orderkey), <>($2, $cor0.l_suppkey), >($12, $11))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})), =($3, $32), =($33, 'BRAZIL'))], variablesSet=[[$cor0]])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[numwait DESC, s_name ASC], offset=[0], limit=[100], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[numwait DESC, s_name ASC], offset=[0], limit=[100], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[s_name], select=[s_name, Final_COUNT(count$0) AS numwait])
         +- Exchange(distribution=[hash[s_name]])
            +- LocalHashAggregate(groupBy=[s_name], select=[s_name, Partial_COUNT(*) AS count$0])
               +- Calc(select=[s_name])
                  +- HashSemiJoin(where=[AND(=(l_orderkey0, l_orderkey), <>(l_suppkey0, l_suppkey))], join=[s_name, l_orderkey, l_suppkey], joinType=[LeftAntiJoin], build=[left])
                     :- HashSemiJoin(where=[AND(=(l_orderkey0, l_orderkey), <>(l_suppkey0, l_suppkey))], join=[s_name, l_orderkey, l_suppkey], joinType=[LeftSemiJoin], build=[left])
                     :  :- Exchange(distribution=[hash[l_orderkey]])
                     :  :  +- Calc(select=[s_name, l_orderkey, l_suppkey])
                     :  :     +- HashJoin(where=[=(s_suppkey, l_suppkey)], join=[l_orderkey, l_suppkey, s_suppkey, s_name], joinType=[InnerJoin], build=[right])
                     :  :        :- Exchange(distribution=[hash[l_suppkey]])
                     :  :        :  +- Calc(select=[l_orderkey, l_suppkey])
                     :  :        :     +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_suppkey, o_orderkey], joinType=[InnerJoin], build=[right])
                     :  :        :        :- Exchange(distribution=[hash[l_orderkey]])
                     :  :        :        :  +- Calc(select=[l_orderkey, l_suppkey], where=[>(l_receiptdate, l_commitdate)])
                     :  :        :        :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate])
                     :  :        :        +- Exchange(distribution=[hash[o_orderkey]])
                     :  :        :           +- Calc(select=[o_orderkey], where=[=(o_orderstatus, 'F')])
                     :  :        :              +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderstatus];filterPredicates=[]]]], fields=[o_orderkey, o_orderstatus])
                     :  :        +- Exchange(distribution=[hash[s_suppkey]])
                     :  :           +- Calc(select=[s_suppkey, s_name])
                     :  :              +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_name, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
                     :  :                 :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_nationkey])
                     :  :                 +- Exchange(distribution=[broadcast])
                     :  :                    +- Calc(select=[n_nationkey], where=[=(n_name, 'BRAZIL')])
                     :  :                       +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                     :  +- Exchange(distribution=[hash[l_orderkey]])
                     :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[l_orderkey, l_suppkey], where=[>(l_receiptdate, l_commitdate)])
                           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=21, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch21 using 1395599672 as a seed to the RNG
select
  s.s_name,
  count(*) as numwait
from
  supplier s,
  lineitem l1,
  orders o,
  nation n
where
  s.s_suppkey = l1.l_suppkey
  and o.o_orderkey = l1.l_orderkey
  and o.o_orderstatus = 'F'
  and l1.l_receiptdate > l1.l_commitdate
  and exists (
    select
      *
    from
      lineitem l2
    where
      l2.l_orderkey = l1.l_orderkey
      and l2.l_suppkey <> l1.l_suppkey
  )
  and not exists (
    select
      *
    from
      lineitem l3
    where
      l3.l_orderkey = l1.l_orderkey
      and l3.l_suppkey <> l1.l_suppkey
      and l3.l_receiptdate > l3.l_commitdate
  )
  and s.s_nationkey = n.n_nationkey
  and n.n_name = 'BRAZIL'
group by
  s.s_name
order by
  numwait desc,
  s.s_name
limit 100
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], sort1=[$0], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first], fetch=[100])
+- LogicalAggregate(group=[{0}], numwait=[COUNT()])
   +- LogicalProject(s_name=[$1])
      +- LogicalFilter(condition=[AND(=($0, $9), =($23, $7), =($25, 'F'), >($19, $18), EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.l_orderkey), <>($2, $cor0.l_suppkey))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
}), NOT(EXISTS({
LogicalFilter(condition=[AND(=($0, $cor0.l_orderkey), <>($2, $cor0.l_suppkey), >($12, $11))])
  LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
})), =($3, $32), =($33, 'BRAZIL'))], variablesSet=[[$cor0]])
         +- LogicalJoin(condition=[true], joinType=[inner])
            :- LogicalJoin(condition=[true], joinType=[inner])
            :  :- LogicalJoin(condition=[true], joinType=[inner])
            :  :  :- LogicalTableScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment];filterPredicates=[]]]])
            :  :  +- LogicalTableScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment];filterPredicates=[]]]])
            :  +- LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
            +- LogicalTableScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name, n_regionkey, n_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[numwait DESC, s_name ASC], offset=[0], limit=[100], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[numwait DESC, s_name ASC], offset=[0], limit=[100], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[s_name], select=[s_name, Final_COUNT(count$0) AS numwait])
         +- Exchange(distribution=[hash[s_name]])
            +- LocalHashAggregate(groupBy=[s_name], select=[s_name, Partial_COUNT(*) AS count$0])
               +- Calc(select=[s_name])
                  +- HashSemiJoin(where=[AND(=(l_orderkey0, l_orderkey), <>(l_suppkey0, l_suppkey))], join=[s_name, l_orderkey, l_suppkey], joinType=[LeftAntiJoin], build=[left])
                     :- HashSemiJoin(where=[AND(=(l_orderkey0, l_orderkey), <>(l_suppkey0, l_suppkey))], join=[s_name, l_orderkey, l_suppkey], joinType=[LeftSemiJoin], build=[left])
                     :  :- Exchange(distribution=[hash[l_orderkey]])
                     :  :  +- Calc(select=[s_name, l_orderkey, l_suppkey])
                     :  :     +- HashJoin(where=[=(s_suppkey, l_suppkey)], join=[l_orderkey, l_suppkey, s_suppkey, s_name], joinType=[InnerJoin], build=[right])
                     :  :        :- Exchange(distribution=[hash[l_suppkey]])
                     :  :        :  +- Calc(select=[l_orderkey, l_suppkey])
                     :  :        :     +- HashJoin(where=[=(o_orderkey, l_orderkey)], join=[l_orderkey, l_suppkey, o_orderkey], joinType=[InnerJoin], build=[right])
                     :  :        :        :- Exchange(distribution=[hash[l_orderkey]])
                     :  :        :        :  +- Calc(select=[l_orderkey, l_suppkey], where=[>(l_receiptdate, l_commitdate)])
                     :  :        :        :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate])
                     :  :        :        +- Exchange(distribution=[hash[o_orderkey]])
                     :  :        :           +- Calc(select=[o_orderkey], where=[=(o_orderstatus, 'F')])
                     :  :        :              +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_orderstatus];filterPredicates=[]]]], fields=[o_orderkey, o_orderstatus])
                     :  :        +- Exchange(distribution=[hash[s_suppkey]])
                     :  :           +- Calc(select=[s_suppkey, s_name])
                     :  :              +- NestedLoopJoin(where=[=(s_nationkey, n_nationkey)], join=[s_suppkey, s_name, s_nationkey, n_nationkey], joinType=[InnerJoin], build=[right])
                     :  :                 :- TableSourceScan(table=[[builtin, default, supplier, source: [TestParquetTableSource -> selectedFields=[s_suppkey, s_name, s_nationkey];filterPredicates=[]]]], fields=[s_suppkey, s_name, s_nationkey])
                     :  :                 +- Exchange(distribution=[broadcast])
                     :  :                    +- Calc(select=[n_nationkey], where=[=(n_name, 'BRAZIL')])
                     :  :                       +- TableSourceScan(table=[[builtin, default, nation, source: [TestParquetTableSource -> selectedFields=[n_nationkey, n_name];filterPredicates=[]]]], fields=[n_nationkey, n_name])
                     :  +- Exchange(distribution=[hash[l_orderkey]])
                     :     +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey])
                     +- Exchange(distribution=[hash[l_orderkey]])
                        +- Calc(select=[l_orderkey, l_suppkey], where=[>(l_receiptdate, l_commitdate)])
                           +- TableSourceScan(table=[[builtin, default, lineitem, source: [TestParquetTableSource -> selectedFields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate];filterPredicates=[]]]], fields=[l_orderkey, l_suppkey, l_commitdate, l_receiptdate])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=22, factor=1,000, statsMode=FULL, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch22 using 1395599672 as a seed to the RNG
select
  cntrycode,
  count(*) as numcust,
  sum(c_acctbal) as totacctbal
from
  (
    select
      substring(c_phone from 1 for 2) as cntrycode,
      c_acctbal
    from
      customer c
    where
      substring(c_phone from 1 for 2) in
        ('24', '31', '11', '16', '21', '20', '34')
      and c_acctbal > (
        select
          avg(c_acctbal)
        from
          customer
        where
          c_acctbal > 0.00
          and substring(c_phone from 1 for 2) in
            ('24', '31', '11', '16', '21', '20', '34')
      )
      and not exists (
        select
          *
        from
          orders o
        where
          o.o_custkey = c.c_custkey
      )
  ) as custsale
group by
  cntrycode
order by
  cntrycode
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], numcust=[COUNT()], totacctbal=[SUM($1)])
   +- LogicalProject(cntrycode=[SUBSTRING($4, 1, 2)], c_acctbal=[$5])
      +- LogicalFilter(condition=[AND(OR(=(SUBSTRING($4, 1, 2), '24'), =(SUBSTRING($4, 1, 2), '31'), =(SUBSTRING($4, 1, 2), '11'), =(SUBSTRING($4, 1, 2), '16'), =(SUBSTRING($4, 1, 2), '21'), =(SUBSTRING($4, 1, 2), '20'), =(SUBSTRING($4, 1, 2), '34')), >($5, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[AVG($0)])
  LogicalProject(c_acctbal=[$5])
    LogicalFilter(condition=[AND(>($5, 0.00), OR(=(SUBSTRING($4, 1, 2), '24'), =(SUBSTRING($4, 1, 2), '31'), =(SUBSTRING($4, 1, 2), '11'), =(SUBSTRING($4, 1, 2), '16'), =(SUBSTRING($4, 1, 2), '21'), =(SUBSTRING($4, 1, 2), '20'), =(SUBSTRING($4, 1, 2), '34')))])
      LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
})), NOT(EXISTS({
LogicalFilter(condition=[=($1, $cor0.c_custkey)])
  LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
         +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[cntrycode ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[cntrycode ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[cntrycode], select=[cntrycode, Final_COUNT(count$0) AS numcust, Final_SUM(sum$1) AS totacctbal])
         +- Exchange(distribution=[hash[cntrycode]])
            +- LocalHashAggregate(groupBy=[cntrycode], select=[cntrycode, Partial_COUNT(*) AS count$0, Partial_SUM(c_acctbal) AS sum$1])
               +- Calc(select=[SUBSTRING(c_phone, 1, 2) AS cntrycode, c_acctbal])
                  +- NestedLoopJoin(where=[>(c_acctbal, EXPR$0)], join=[c_phone, c_acctbal, EXPR$0], joinType=[InnerJoin], build=[right], singleRowJoin=[true])
                     :- Calc(select=[c_phone, c_acctbal])
                     :  +- HashSemiJoin(where=[=(o_custkey, c_custkey)], join=[c_custkey, c_phone, c_acctbal], joinType=[LeftAntiJoin], build=[left], tryDistinctBuildRow=[true])
                     :     :- Exchange(distribution=[hash[c_custkey]])
                     :     :  +- Calc(select=[c_custkey, c_phone, c_acctbal], where=[IN(SUBSTRING(c_phone, 1, 2), '24', '31', '11', '16', '21', '20', '34')])
                     :     :     +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_phone, c_acctbal];filterPredicates=[]]]], fields=[c_custkey, c_phone, c_acctbal])
                     :     +- Exchange(distribution=[hash[o_custkey]])
                     :        +- LocalHashAggregate(groupBy=[o_custkey], select=[o_custkey])
                     :           +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_custkey];filterPredicates=[]]]], fields=[o_custkey])
                     +- Exchange(distribution=[broadcast])
                        +- HashAggregate(isMerge=[true], select=[Final_AVG(sum$0, count$1) AS EXPR$0])
                           +- Exchange(distribution=[single])
                              +- LocalHashAggregate(select=[Partial_AVG(c_acctbal) AS (sum$0, count$1)])
                                 +- Calc(select=[c_acctbal], where=[AND(>(c_acctbal, 0.00), IN(SUBSTRING(c_phone, 1, 2), '24', '31', '11', '16', '21', '20', '34'))])
                                    +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_phone, c_acctbal];filterPredicates=[]]]], fields=[c_phone, c_acctbal])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=22, factor=1,000, statsMode=ROW_COUNT, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch22 using 1395599672 as a seed to the RNG
select
  cntrycode,
  count(*) as numcust,
  sum(c_acctbal) as totacctbal
from
  (
    select
      substring(c_phone from 1 for 2) as cntrycode,
      c_acctbal
    from
      customer c
    where
      substring(c_phone from 1 for 2) in
        ('24', '31', '11', '16', '21', '20', '34')
      and c_acctbal > (
        select
          avg(c_acctbal)
        from
          customer
        where
          c_acctbal > 0.00
          and substring(c_phone from 1 for 2) in
            ('24', '31', '11', '16', '21', '20', '34')
      )
      and not exists (
        select
          *
        from
          orders o
        where
          o.o_custkey = c.c_custkey
      )
  ) as custsale
group by
  cntrycode
order by
  cntrycode
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], numcust=[COUNT()], totacctbal=[SUM($1)])
   +- LogicalProject(cntrycode=[SUBSTRING($4, 1, 2)], c_acctbal=[$5])
      +- LogicalFilter(condition=[AND(OR(=(SUBSTRING($4, 1, 2), '24'), =(SUBSTRING($4, 1, 2), '31'), =(SUBSTRING($4, 1, 2), '11'), =(SUBSTRING($4, 1, 2), '16'), =(SUBSTRING($4, 1, 2), '21'), =(SUBSTRING($4, 1, 2), '20'), =(SUBSTRING($4, 1, 2), '34')), >($5, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[AVG($0)])
  LogicalProject(c_acctbal=[$5])
    LogicalFilter(condition=[AND(>($5, 0.00), OR(=(SUBSTRING($4, 1, 2), '24'), =(SUBSTRING($4, 1, 2), '31'), =(SUBSTRING($4, 1, 2), '11'), =(SUBSTRING($4, 1, 2), '16'), =(SUBSTRING($4, 1, 2), '21'), =(SUBSTRING($4, 1, 2), '20'), =(SUBSTRING($4, 1, 2), '34')))])
      LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
})), NOT(EXISTS({
LogicalFilter(condition=[=($1, $cor0.c_custkey)])
  LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
         +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[cntrycode ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[cntrycode ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[cntrycode], select=[cntrycode, Final_COUNT(count$0) AS numcust, Final_SUM(sum$1) AS totacctbal])
         +- Exchange(distribution=[hash[cntrycode]])
            +- LocalHashAggregate(groupBy=[cntrycode], select=[cntrycode, Partial_COUNT(*) AS count$0, Partial_SUM(c_acctbal) AS sum$1])
               +- Calc(select=[SUBSTRING(c_phone, 1, 2) AS cntrycode, c_acctbal])
                  +- NestedLoopJoin(where=[>(c_acctbal, EXPR$0)], join=[c_phone, c_acctbal, EXPR$0], joinType=[InnerJoin], build=[right], singleRowJoin=[true])
                     :- Calc(select=[c_phone, c_acctbal])
                     :  +- HashSemiJoin(where=[=(o_custkey, c_custkey)], join=[c_custkey, c_phone, c_acctbal], joinType=[LeftAntiJoin], build=[left])
                     :     :- Exchange(distribution=[hash[c_custkey]])
                     :     :  +- Calc(select=[c_custkey, c_phone, c_acctbal], where=[IN(SUBSTRING(c_phone, 1, 2), '24', '31', '11', '16', '21', '20', '34')])
                     :     :     +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_phone, c_acctbal];filterPredicates=[]]]], fields=[c_custkey, c_phone, c_acctbal])
                     :     +- Exchange(distribution=[hash[o_custkey]])
                     :        +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_custkey];filterPredicates=[]]]], fields=[o_custkey])
                     +- Exchange(distribution=[broadcast])
                        +- HashAggregate(isMerge=[true], select=[Final_AVG(sum$0, count$1) AS EXPR$0])
                           +- Exchange(distribution=[single])
                              +- LocalHashAggregate(select=[Partial_AVG(c_acctbal) AS (sum$0, count$1)])
                                 +- Calc(select=[c_acctbal], where=[AND(>(c_acctbal, 0.00), IN(SUBSTRING(c_phone, 1, 2), '24', '31', '11', '16', '21', '20', '34'))])
                                    +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_phone, c_acctbal];filterPredicates=[]]]], fields=[c_phone, c_acctbal])
]]>
    </Resource>
  </TestCase>
  <TestCase name="test[caseName=22, factor=1,000, statsMode=PART, joinReorder=true]">
    <Resource name="sql">
      <![CDATA[-- tpch22 using 1395599672 as a seed to the RNG
select
  cntrycode,
  count(*) as numcust,
  sum(c_acctbal) as totacctbal
from
  (
    select
      substring(c_phone from 1 for 2) as cntrycode,
      c_acctbal
    from
      customer c
    where
      substring(c_phone from 1 for 2) in
        ('24', '31', '11', '16', '21', '20', '34')
      and c_acctbal > (
        select
          avg(c_acctbal)
        from
          customer
        where
          c_acctbal > 0.00
          and substring(c_phone from 1 for 2) in
            ('24', '31', '11', '16', '21', '20', '34')
      )
      and not exists (
        select
          *
        from
          orders o
        where
          o.o_custkey = c.c_custkey
      )
  ) as custsale
group by
  cntrycode
order by
  cntrycode
]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], dir0=[ASC-nulls-first])
+- LogicalAggregate(group=[{0}], numcust=[COUNT()], totacctbal=[SUM($1)])
   +- LogicalProject(cntrycode=[SUBSTRING($4, 1, 2)], c_acctbal=[$5])
      +- LogicalFilter(condition=[AND(OR(=(SUBSTRING($4, 1, 2), '24'), =(SUBSTRING($4, 1, 2), '31'), =(SUBSTRING($4, 1, 2), '11'), =(SUBSTRING($4, 1, 2), '16'), =(SUBSTRING($4, 1, 2), '21'), =(SUBSTRING($4, 1, 2), '20'), =(SUBSTRING($4, 1, 2), '34')), >($5, $SCALAR_QUERY({
LogicalAggregate(group=[{}], EXPR$0=[AVG($0)])
  LogicalProject(c_acctbal=[$5])
    LogicalFilter(condition=[AND(>($5, 0.00), OR(=(SUBSTRING($4, 1, 2), '24'), =(SUBSTRING($4, 1, 2), '31'), =(SUBSTRING($4, 1, 2), '11'), =(SUBSTRING($4, 1, 2), '16'), =(SUBSTRING($4, 1, 2), '21'), =(SUBSTRING($4, 1, 2), '20'), =(SUBSTRING($4, 1, 2), '34')))])
      LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
})), NOT(EXISTS({
LogicalFilter(condition=[=($1, $cor0.c_custkey)])
  LogicalTableScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment];filterPredicates=[]]]])
})))], variablesSet=[[$cor0]])
         +- LogicalTableScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment];filterPredicates=[]]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
SortLimit(orderBy=[cntrycode ASC], offset=[0], limit=[200], global=[true])
+- Exchange(distribution=[single])
   +- SortLimit(orderBy=[cntrycode ASC], offset=[0], limit=[200], global=[false])
      +- HashAggregate(isMerge=[true], groupBy=[cntrycode], select=[cntrycode, Final_COUNT(count$0) AS numcust, Final_SUM(sum$1) AS totacctbal])
         +- Exchange(distribution=[hash[cntrycode]])
            +- LocalHashAggregate(groupBy=[cntrycode], select=[cntrycode, Partial_COUNT(*) AS count$0, Partial_SUM(c_acctbal) AS sum$1])
               +- Calc(select=[SUBSTRING(c_phone, 1, 2) AS cntrycode, c_acctbal])
                  +- NestedLoopJoin(where=[>(c_acctbal, EXPR$0)], join=[c_phone, c_acctbal, EXPR$0], joinType=[InnerJoin], build=[right], singleRowJoin=[true])
                     :- Calc(select=[c_phone, c_acctbal])
                     :  +- HashSemiJoin(where=[=(o_custkey, c_custkey)], join=[c_custkey, c_phone, c_acctbal], joinType=[LeftAntiJoin], build=[left])
                     :     :- Exchange(distribution=[hash[c_custkey]])
                     :     :  +- Calc(select=[c_custkey, c_phone, c_acctbal], where=[IN(SUBSTRING(c_phone, 1, 2), '24', '31', '11', '16', '21', '20', '34')])
                     :     :     +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_custkey, c_phone, c_acctbal];filterPredicates=[]]]], fields=[c_custkey, c_phone, c_acctbal])
                     :     +- Exchange(distribution=[hash[o_custkey]])
                     :        +- TableSourceScan(table=[[builtin, default, orders, source: [TestParquetTableSource -> selectedFields=[o_custkey];filterPredicates=[]]]], fields=[o_custkey])
                     +- Exchange(distribution=[broadcast])
                        +- HashAggregate(isMerge=[true], select=[Final_AVG(sum$0, count$1) AS EXPR$0])
                           +- Exchange(distribution=[single])
                              +- LocalHashAggregate(select=[Partial_AVG(c_acctbal) AS (sum$0, count$1)])
                                 +- Calc(select=[c_acctbal], where=[AND(>(c_acctbal, 0.00), IN(SUBSTRING(c_phone, 1, 2), '24', '31', '11', '16', '21', '20', '34'))])
                                    +- TableSourceScan(table=[[builtin, default, customer, source: [TestParquetTableSource -> selectedFields=[c_phone, c_acctbal];filterPredicates=[]]]], fields=[c_phone, c_acctbal])
]]>
    </Resource>
  </TestCase>
</Root>
